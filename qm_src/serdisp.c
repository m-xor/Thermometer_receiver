/*$file${qm_src::serdisp.c} ################################################*/
/*
* Model: balkonowy_rx_ult_.qm
* File:  ${qm_src::serdisp.c}
*
* This code has been generated by QM 4.3.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${qm_src::serdisp.c} #############################################*/
#include "qpc.h"
//#include "bsp-serdisp.h"
#include "bsp.h"
#include "project.h"
#include "serdisp.h"
#include "link-proto.h"
#include "led7seg.h"
#include "serdisperr.h"
#include "serdispminmax.h"
#include <limits.h>

Q_DEFINE_THIS_FILE

#define NAN ALL_MINUS

//definicje symboli (poddefinicje są zdefinowane w bsp.h)
//do ilu sek. od ostatniego msg dana będzie uznana za aktualną
#define ASSUME_AGED    ((DISPLAY_ASSUME_AGED)*60*BSP_SOFT_TIMER_TICKS_PER_SEC)
//po ilu sekundach temp. zewnętrzna będzie uznana za całkowicie nieaktualną
#define ASSUME_OUTDATED  ((DISPLAY_ASSUME_OUTDATED)*60*BSP_SOFT_TIMER_TICKS_PER_SEC)
//częstotliwość mrugania wyświetlacza dla ASSUME_AGED
#define BLINK_DISPLAY (BSP_TICKS_PER_SEC/DISPLAY_AGED_BLINK_PER_SEC/2)

/* local objects -----------------------------------------------------------*/

/*$declare${AOs::SerDisp} ##################################################*/
/*${AOs::SerDisp} ..........................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt timeoutEvt;
    QTimeEvt blinkEvt;
    int16_t lastRoundTemp;
    QHsm * orthoCompPtr;
    QHsm * minmaxOrthoPtr;
} SerDisp;

/* private: */
static int16_t SerDisp_roundValue(SerDisp * const me, int16_t val, uint8_t den);

/* protected: */
static QState SerDisp_initial(SerDisp * const me, QEvt const * const e);
static QState SerDisp_display(SerDisp * const me, QEvt const * const e);
static QState SerDisp_blink(SerDisp * const me, QEvt const * const e);
static QState SerDisp_blink_on(SerDisp * const me, QEvt const * const e);
static QState SerDisp_blink_off(SerDisp * const me, QEvt const * const e);
static QState SerDisp_handover(SerDisp * const me, QEvt const * const e);
static QState SerDisp_handover_blink(SerDisp * const me, QEvt const * const e);
static QState SerDisp_run(SerDisp * const me, QEvt const * const e);
static QState SerDisp_minimax(SerDisp * const me, QEvt const * const e);
static QState SerDisp_minimax_blink(SerDisp * const me, QEvt const * const e);
/*$enddecl${AOs::SerDisp} ##################################################*/
static SerDisp l_serDisp; /* the sole instance of the SerDisp active object */
//static QTicker l_ticker0; /* ticker active object for tick rate 0 */

/* Public-scope objects ----------------------------------------------------*/

/* Check for the minimum required QP version */
#if (QP_VERSION < 630U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.3.0 or higher required
#endif

/*$define${AOs::AO_SerDisp} ################################################*/
/*${AOs::AO_SerDisp} .......................................................*/
QActive * const AO_SerDisp = &l_serDisp.super;
/*$enddef${AOs::AO_SerDisp} ################################################*/
//$define(AOs::the_Ticker0)

/* Active object definition ================================================*/

/*$define${AOs::SerDisp_ctor} ##############################################*/
/*${AOs::SerDisp_ctor} .....................................................*/
void SerDisp_ctor(void) {
    SerDisp * const me = &l_serDisp;

    QActive_ctor(&me->super, Q_STATE_CAST(&SerDisp_initial));

    //inicjacja komponentu ortho
    me->orthoCompPtr = SerDispErr_ctor(&me->super);

    //inicjacja drugiego komponentu ortogonalnego
    me->minmaxOrthoPtr = SerDispMinMax_ctor(&me->super);

    //inicjacja timerów
    QTimeEvt_ctorX(&me->blinkEvt, &me->super, DISP_BLINK_SIG, HARD_TICKRATE_1);
    //Dla uniknięcia wyścigu ten timer musi być zrealizowany przez obiekt QTimer
    //o priorytecie NIŻSZYM niż AO SerDisp
    QTimeEvt_ctorX(&me->timeoutEvt, &me->super, TIMEOUT_SIG, SOFT_TICKRATE_0);
}
/*$enddef${AOs::SerDisp_ctor} ##############################################*/
/*$define${AOs::SerDisp} ###################################################*/
/*${AOs::SerDisp} ..........................................................*/
/*${AOs::SerDisp::roundValue} ..............................................*/
static int16_t SerDisp_roundValue(SerDisp * const me, int16_t val, uint8_t den) {
    (void)me;
    uint16_t value, rest=0;
    bool subzero = false;

    /* to not to lose special symbols coded out of range of variable*/
    if(val>SPEC_SIGNS_GUARD)
        return val;

    if(val == INT16_MIN)
    {
        value = INT16_MAX + 1U;
    }
    else if( val<0 )
    {
        value = - val;
        subzero = true;
    }
    else
        value = val;

    while(den--)
    {
        rest = value % 10;
        value /= 10;
    }

    value += (rest>=5);
    if( !value && subzero ) return ZERO_MINUS; /* that's right! */
    //return ((val<0)?-value:value);
    return (subzero?-value:value);

}

/*${AOs::SerDisp::SM} ......................................................*/
static QState SerDisp_initial(SerDisp * const me, QEvt const * const e) {
    /*${AOs::SerDisp::SM::initial} */
    (void)e;

    QHSM_INIT(me->orthoCompPtr, (QEvt *)0);
    QHSM_INIT(me->minmaxOrthoPtr, (QEvt *)0);

    QActive_subscribe(&me->super, OTEMP_SIG);
    QActive_subscribe(&me->super, BATT_SIG);
    QActive_subscribe(&me->super, TX_ERR_SIG);
    QActive_subscribe(&me->super, ERR_SIG);
    QActive_subscribe(&me->super, TX_HALT_SIG);

    QActive_subscribe(&me->super, BTN_PRSS_SIG);
    QActive_subscribe(&me->super, BTN_REL_SIG);

    QActive_subscribe(&me->super, MIN_TEMP_SIG);
    QActive_subscribe(&me->super, MAX_TEMP_SIG);
    QActive_subscribe(&me->super, BTN_SHORT_SIG);


    me->lastRoundTemp = NAN;

    QS_OBJ_DICTIONARY(AO_SerDisp);

    QS_FUN_DICTIONARY(&SerDisp_display);
    QS_FUN_DICTIONARY(&SerDisp_blink);
    QS_FUN_DICTIONARY(&SerDisp_blink_on);
    QS_FUN_DICTIONARY(&SerDisp_blink_off);
    QS_FUN_DICTIONARY(&SerDisp_handover);
    QS_FUN_DICTIONARY(&SerDisp_handover_blink);
    QS_FUN_DICTIONARY(&SerDisp_run);
    QS_FUN_DICTIONARY(&SerDisp_minimax);
    QS_FUN_DICTIONARY(&SerDisp_minimax_blink);

    return Q_TRAN(&SerDisp_display);
}
/*${AOs::SerDisp::SM::display} .............................................*/
static QState SerDisp_display(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&SerDisp_run);
            break;
        }
        /*${AOs::SerDisp::SM::display::TX_HALT} */
        case TX_HALT_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::TX_ERR} */
        case TX_ERR_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::ERR} */
        case ERR_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::BATT} */
        case BATT_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::ORTHO_BLINK} */
        case ORTHO_BLINK_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::OTEMP} */
        case OTEMP_SIG: {
            me->lastRoundTemp =
                    SerDisp_roundValue(me,
                            Q_EVT_CAST(ValEvt)->value,
                            Q_EVT_CAST(ValEvt)->denom);


            QTimeEvt_rearm(&me->timeoutEvt,  ASSUME_AGED);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::MINMAX_TIMEOUT} */
        case MINMAX_TIMEOUT_SIG: {
            QHSM_DISPATCH(me->minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::MIN_TEMP} */
        case MIN_TEMP_SIG: {
            ValEvt pe = { {MIN_TEMP_SIG, 0, 0}, 0, 0 };

            pe.value =
                SerDisp_roundValue(me,
                        Q_EVT_CAST(ValEvt)->value,
                        Q_EVT_CAST(ValEvt)->denom);


            QHSM_DISPATCH(me->minmaxOrthoPtr, (QEvt *)&pe); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::MAX_TEMP} */
        case MAX_TEMP_SIG: {
            ValEvt pe = { {MAX_TEMP_SIG, 0, 0}, 0, 0 };

            pe.value =
                SerDisp_roundValue(me,
                        Q_EVT_CAST(ValEvt)->value,
                        Q_EVT_CAST(ValEvt)->denom);


            QHSM_DISPATCH(me->minmaxOrthoPtr, (QEvt *)&pe); /* direct dispatch */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::blink} ......................................*/
static QState SerDisp_blink(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::blink} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->blinkEvt,  BLINK_DISPLAY, BLINK_DISPLAY);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::blink} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->blinkEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::blink::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&SerDisp_blink_off);
            break;
        }
        /*${AOs::SerDisp::SM::display::blink::TIMEOUT} */
        case TIMEOUT_SIG: {
            me->lastRoundTemp = NAN;
            status_ = Q_TRAN(&SerDisp_run);
            break;
        }
        /*${AOs::SerDisp::SM::display::blink::BTN_PRSS} */
        case BTN_PRSS_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_handover_blink);
            break;
        }
        /*${AOs::SerDisp::SM::display::blink::OTEMP} */
        case OTEMP_SIG: {

            me->lastRoundTemp =
                SerDisp_roundValue(me,
                        Q_EVT_CAST(ValEvt)->value,
                        Q_EVT_CAST(ValEvt)->denom);

            QTimeEvt_rearm(&me->timeoutEvt,  ASSUME_AGED);

            status_ = Q_TRAN(&SerDisp_run);
            break;
        }
        /*${AOs::SerDisp::SM::display::blink::BTN_SHORT} */
        case BTN_SHORT_SIG: {
            QHSM_DISPATCH(me->minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_minimax_blink);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_display);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::blink::blink_on} ............................*/
static QState SerDisp_blink_on(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::blink::blink_on} */
        case Q_ENTRY_SIG: {
            led_display_number(me->lastRoundTemp, 10);
            led_show();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::blink::blink_on::DISP_BLINK} */
        case DISP_BLINK_SIG: {
            status_ = Q_TRAN(&SerDisp_blink_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_blink);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::blink::blink_off} ...........................*/
static QState SerDisp_blink_off(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::blink::blink_off} */
        case Q_ENTRY_SIG: {
            led_clear_buff();
            led_show();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::blink::blink_off::DISP_BLINK} */
        case DISP_BLINK_SIG: {
            status_ = Q_TRAN(&SerDisp_blink_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_blink);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::handover} ...................................*/
static QState SerDisp_handover(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::handover::TIMEOUT} */
        case TIMEOUT_SIG: {
            QTimeEvt_armX(&me->timeoutEvt,  ASSUME_OUTDATED-ASSUME_AGED, 0U);
            status_ = Q_TRAN(&SerDisp_handover_blink);
            break;
        }
        /*${AOs::SerDisp::SM::display::handover::BTN_REL} */
        case BTN_REL_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_run);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_display);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::handover::handover_blink} ...................*/
static QState SerDisp_handover_blink(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::handover::handover_blink::BTN_REL} */
        case BTN_REL_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_blink);
            break;
        }
        /*${AOs::SerDisp::SM::display::handover::handover_blink::TIMEOUT} */
        case TIMEOUT_SIG: {
            me->lastRoundTemp = NAN;
            status_ = Q_TRAN(&SerDisp_handover);
            break;
        }
        /*${AOs::SerDisp::SM::display::handover::handover_blink::OTEMP} */
        case OTEMP_SIG: {

            me->lastRoundTemp =
                SerDisp_roundValue(me,
                        Q_EVT_CAST(ValEvt)->value,
                        Q_EVT_CAST(ValEvt)->denom);

            QTimeEvt_rearm(&me->timeoutEvt,  ASSUME_AGED);

            status_ = Q_TRAN(&SerDisp_handover);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_handover);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::run} ........................................*/
static QState SerDisp_run(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::run} */
        case Q_ENTRY_SIG: {

            led_display_number(me->lastRoundTemp, 10);
            led_show();

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::run::BTN_PRSS} */
        case BTN_PRSS_SIG: {
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_handover);
            break;
        }
        /*${AOs::SerDisp::SM::display::run::TIMEOUT} */
        case TIMEOUT_SIG: {
            QTimeEvt_armX(&me->timeoutEvt,  ASSUME_OUTDATED-ASSUME_AGED, 0U);
            status_ = Q_TRAN(&SerDisp_blink);
            break;
        }
        /*${AOs::SerDisp::SM::display::run::OTEMP} */
        case OTEMP_SIG: {

            //timer może być uzbrojony lub nie
            QTimeEvt_rearm(&me->timeoutEvt,  ASSUME_AGED);

            me->lastRoundTemp = SerDisp_roundValue(me,
                        Q_EVT_CAST(ValEvt)->value,
                        Q_EVT_CAST(ValEvt)->denom);

            //aktualizuj wyświetlacz
            led_display_number(me->lastRoundTemp, 10);
            led_show();

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDisp::SM::display::run::BTN_SHORT} */
        case BTN_SHORT_SIG: {
            QHSM_DISPATCH(me->minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_minimax);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_display);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::minimax} ....................................*/
static QState SerDisp_minimax(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::minimax::RET_ORTHO} */
        case RET_ORTHO_SIG: {
            status_ = Q_TRAN(&SerDisp_run);
            break;
        }
        /*${AOs::SerDisp::SM::display::minimax::TIMEOUT} */
        case TIMEOUT_SIG: {
            QTimeEvt_armX(&me->timeoutEvt,  ASSUME_OUTDATED-ASSUME_AGED, 0U);
            status_ = Q_TRAN(&SerDisp_minimax_blink);
            break;
        }
        /*${AOs::SerDisp::SM::display::minimax::BTN_PRSS} */
        case BTN_PRSS_SIG: {
            QHSM_DISPATCH(me->minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_handover);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_display);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDisp::SM::display::minimax::minimax_blink} .....................*/
static QState SerDisp_minimax_blink(SerDisp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDisp::SM::display::minimax::minimax_blink::RET_ORTHO} */
        case RET_ORTHO_SIG: {
            status_ = Q_TRAN(&SerDisp_blink);
            break;
        }
        /*${AOs::SerDisp::SM::display::minimax::minimax_blink::OTEMP} */
        case OTEMP_SIG: {

            me->lastRoundTemp =
                SerDisp_roundValue(me,
                        Q_EVT_CAST(ValEvt)->value,
                        Q_EVT_CAST(ValEvt)->denom);

            QTimeEvt_rearm(&me->timeoutEvt,  ASSUME_AGED);

            status_ = Q_TRAN(&SerDisp_minimax);
            break;
        }
        /*${AOs::SerDisp::SM::display::minimax::minimax_blink::TIMEOUT} */
        case TIMEOUT_SIG: {
            me->lastRoundTemp = NAN;
            status_ = Q_TRAN(&SerDisp_minimax);
            break;
        }
        /*${AOs::SerDisp::SM::display::minimax::minimax_blink::BTN_PRSS} */
        case BTN_PRSS_SIG: {
            QHSM_DISPATCH(me->minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */
            QHSM_DISPATCH(me->orthoCompPtr, (QEvt *)e); /* direct dispatch */
            status_ = Q_TRAN(&SerDisp_handover_blink);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDisp_minimax);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::SerDisp} ###################################################*/
