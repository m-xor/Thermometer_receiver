/*$file${qm_src::data.c} ###################################################*/
/*
* Model: balkonowy_rx_ult_.qm
* File:  ${qm_src::data.c}
*
* This code has been generated by QM 4.3.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${qm_src::data.c} ################################################*/
#include "qpc.h"
#include "bsp.h"
#include "app_conf.h"
#include "protocol.h"
#include "project.h"
#include "datahist.h"
#include "data.h"

Q_DEFINE_THIS_FILE

#define MESSAGE_PERIOD (BSP_MSG_INTERVAL * BSP_SOFT_TIMER_TICKS_PER_SEC)
#define MESSAGE_MARGIN (((MSG_REPEAT_NUM-1)+5) * BSP_TICKS_PER_SEC)


/* local objects -----------------------------------------------------------*/

/*$declare${AOs::Data} #####################################################*/
/*${AOs::Data} .............................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt timer;
    QTimeEvt delay;
    uint8_t denominator;
} Data;

/* private: */
static void Data_pubData(Data * const me, int16_t min, int16_t max);

/* protected: */
static QState Data_initial(Data * const me, QEvt const * const e);
static QState Data_cont(Data * const me, QEvt const * const e);
static QState Data_delay(Data * const me, QEvt const * const e);
static QState Data_wait(Data * const me, QEvt const * const e);
/*$enddecl${AOs::Data} #####################################################*/

static Data l_data; /* the sole instance of this active object */


/* Public-scope objects ----------------------------------------------------*/

/* Check for the minimum required QP version */
#if (QP_VERSION < 630U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.3.0 or higher required
#endif

/*$define${AOs::AO_Data} ###################################################*/
/*${AOs::AO_Data} ..........................................................*/
QActive * const AO_Data = &l_data.super;
/*$enddef${AOs::AO_Data} ###################################################*/

/* Active object definition ================================================*/

/*$define${AOs::Data_ctor} #################################################*/
/*${AOs::Data_ctor} ........................................................*/
void Data_ctor(void) {
    Data * const me = &l_data;

    QActive_ctor(&me->super, Q_STATE_CAST(&Data_initial));

    //inicjacja timera
    QTimeEvt_ctorX(&me->timer, &me->super, TIMEOUT_SIG, SOFT_TICKRATE_0);
    QTimeEvt_ctorX(&me->delay, &me->super, DELAY_TIMEOUT_SIG, HARD_TICKRATE_1);
}
/*$enddef${AOs::Data_ctor} #################################################*/
/*$define${AOs::Data} ######################################################*/
/*${AOs::Data} .............................................................*/
/*${AOs::Data::pubData} ....................................................*/
static void Data_pubData(Data * const me, int16_t min, int16_t max) {
    ValEvt *pe = Q_NEW(ValEvt, MIN_TEMP_SIG);
    pe->denom = me->denominator;
    pe->value = min;
    QF_PUBLISH((QEvt*)pe, me);
    pe = Q_NEW(ValEvt, MAX_TEMP_SIG);
    pe->denom = me->denominator;
    pe->value = max;
    QF_PUBLISH((QEvt*)pe, me);

    QS_BEGIN(MINIMAX_STAT,me)
        QS_I16(0, min);
        QS_I16(0, max);
        QS_I16(0, me->denominator);
    QS_END()
}

/*${AOs::Data::SM} .........................................................*/
static QState Data_initial(Data * const me, QEvt const * const e) {
    /*${AOs::Data::SM::initial} */
    (void)e;

    //for(int16_t i=0; i<DATA_STOR_SIZE; i++)
    //{
    //    me->storage[i] = DROP_MARK;
    //}
    //me->current_index = 0;
    //me->denominator = 0;

    data_init();

    QActive_subscribe(&me->super, OTEMP_SIG);

    QTimeEvt_armX(&me->timer,  MESSAGE_PERIOD, MESSAGE_PERIOD);

    QS_OBJ_DICTIONARY(&l_data);

    QS_FUN_DICTIONARY(&Data_cont);
    QS_FUN_DICTIONARY(&Data_delay);
    QS_FUN_DICTIONARY(&Data_wait);

    return Q_TRAN(&Data_wait);
}
/*${AOs::Data::SM::cont} ...................................................*/
static QState Data_cont(Data * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Data::SM::cont::UPDATE_MINMAX} */
        case UPDATE_MINMAX_SIG: {
            int16_t min, max;
            data_get(&min, &max);
            Data_pubData(me,
                (min==DROP_MARK)?NAN_MINMAX:min,
                (max==DROP_MARK)?NAN_MINMAX:max);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Data::SM::cont::delay} ............................................*/
static QState Data_delay(Data * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Data::SM::cont::delay} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->delay,  MESSAGE_MARGIN, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Data::SM::cont::delay} */
        case Q_EXIT_SIG: {
            QACTIVE_POST(&me->super,Q_NEW(QEvt, UPDATE_MINMAX_SIG), me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Data::SM::cont::delay::OTEMP} */
        case OTEMP_SIG: {
            QTimeEvt_rearm(&me->timer,  MESSAGE_PERIOD);
            //Data_saveData(me,Q_EVT_CAST(ValEvt)->value, Q_EVT_CAST(ValEvt)->denom);
            data_save(Q_EVT_CAST(ValEvt)->value);
            me->denominator = Q_EVT_CAST(ValEvt)->denom;
            status_ = Q_TRAN(&Data_wait);
            break;
        }
        /*${AOs::Data::SM::cont::delay::DELAY_TIMEOUT} */
        case DELAY_TIMEOUT_SIG: {
            //Data_saveData(me,DROP_MARK, me->denominator);
            data_save(DROP_MARK);
            status_ = Q_TRAN(&Data_wait);
            break;
        }
        default: {
            status_ = Q_SUPER(&Data_cont);
            break;
        }
    }
    return status_;
}
/*${AOs::Data::SM::cont::wait} .............................................*/
static QState Data_wait(Data * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Data::SM::cont::wait::OTEMP} */
        case OTEMP_SIG: {
            QTimeEvt_rearm(&me->timer,  MESSAGE_PERIOD);

            //Data_saveData(me,Q_EVT_CAST(ValEvt)->value, Q_EVT_CAST(ValEvt)->denom);
            data_save(Q_EVT_CAST(ValEvt)->value);
            me->denominator = Q_EVT_CAST(ValEvt)->denom;

            //QEvt *pe = Q_NEW(QEvt, UPDATE_MINMAX_SIG);
            //QACTIVE_POST(AO_Data,pe, me);

            QACTIVE_POST(&me->super,Q_NEW(QEvt, UPDATE_MINMAX_SIG), me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Data::SM::cont::wait::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&Data_delay);
            break;
        }
        default: {
            status_ = Q_SUPER(&Data_cont);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Data} ######################################################*/
