/*$file${qm_src::data.c} ###################################################*/
/*
* Model: balkonowy_rx_ult_.qm
* File:  ${qm_src::data.c}
*
* This code has been generated by QM 4.3.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${qm_src::data.c} ################################################*/
#include "qpc.h"
//#include "bsp.h"
#include "app_conf.h"
#include "protocol.h"
#include "project.h"
#include "data.h"

Q_DEFINE_THIS_FILE

//definicje symboli (poddefinicje sÄ… zdefinowane w app_conf.h)

#define MESSAGE_PERIOD (BSP_MSG_INTERVAL * BSP_SOFT_TIMER_TICKS_PER_SEC)
#define MESSAGE_MARGIN (((MSG_REPEAT_NUM-1)+5) * BSP_TICKS_PER_SEC)

#define DATA_STOR_SIZE    (SAVED_DATA_SCOPE*60*60/BSP_MSG_INTERVAL)

#define NAN (INT16_MIN)

/* local objects -----------------------------------------------------------*/

/*$declare${AOs::Data} #####################################################*/
/*${AOs::Data} .............................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt timer;
    QTimeEvt delay;
    int16_t storage[DATA_STOR_SIZE];
    uint16_t current_index;
    uint8_t denominator;
} Data;

/* private: */
static void Data_saveData(Data * const me, int16_t value, uint8_t denominator);

/* protected: */
static QState Data_initial(Data * const me, QEvt const * const e);
static QState Data_delay(Data * const me, QEvt const * const e);
static QState Data_wait(Data * const me, QEvt const * const e);
/*$enddecl${AOs::Data} #####################################################*/

static Data l_data; /* the sole instance of this active object */


/* Public-scope objects ----------------------------------------------------*/

/* Check for the minimum required QP version */
#if (QP_VERSION < 630U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.3.0 or higher required
#endif

/*$define${AOs::AO_Data} ###################################################*/
/*${AOs::AO_Data} ..........................................................*/
QActive * const AO_Data = &l_data.super;
/*$enddef${AOs::AO_Data} ###################################################*/

/* Active object definition ================================================*/

/*$define${AOs::Data_ctor} #################################################*/
/*${AOs::Data_ctor} ........................................................*/
void Data_ctor(void) {
    Data * const me = &l_data;

    QActive_ctor(&me->super, Q_STATE_CAST(&Data_initial));

    //inicjacja timera
    QTimeEvt_ctorX(&me->timer, &me->super, TIMEOUT_SIG, SOFT_TICKRATE_0);
    QTimeEvt_ctorX(&me->delay, &me->super, DELAY_TIMEOUT_SIG, HARD_TICKRATE_1);
}
/*$enddef${AOs::Data_ctor} #################################################*/
/*$define${AOs::Data} ######################################################*/
/*${AOs::Data} .............................................................*/
/*${AOs::Data::saveData} ...................................................*/
static void Data_saveData(Data * const me, int16_t value, uint8_t denominator) {
    me->denominator = denominator;
    me->storage[me->current_index++] =  value;
    if(me->current_index >= DATA_STOR_SIZE)
        me->current_index = 0;
}

/*${AOs::Data::SM} .........................................................*/
static QState Data_initial(Data * const me, QEvt const * const e) {
    /*${AOs::Data::SM::initial} */
    (void)e;

    for(int16_t i=0; i<DATA_STOR_SIZE; i++)
    {
        me->storage[i] = NAN;
    }
    me->current_index = 0;
    me->denominator = 0;

    QActive_subscribe(&me->super, OTEMP_SIG);

    QTimeEvt_armX(&me->timer,  MESSAGE_PERIOD, MESSAGE_PERIOD);

    QS_OBJ_DICTIONARY(&l_data);

    QS_FUN_DICTIONARY(&Data_delay);
    QS_FUN_DICTIONARY(&Data_wait);

    return Q_TRAN(&Data_wait);
}
/*${AOs::Data::SM::delay} ..................................................*/
static QState Data_delay(Data * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Data::SM::delay} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->delay,  MESSAGE_MARGIN, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Data::SM::delay::OTEMP} */
        case OTEMP_SIG: {
            QTimeEvt_rearm(&me->timer,  MESSAGE_PERIOD);
            Data_saveData(me,Q_EVT_CAST(ValEvt)->value, Q_EVT_CAST(ValEvt)->denom);
            status_ = Q_TRAN(&Data_wait);
            break;
        }
        /*${AOs::Data::SM::delay::DELAY_TIMEOUT} */
        case DELAY_TIMEOUT_SIG: {
            Data_saveData(me,NAN, me->denominator);
            status_ = Q_TRAN(&Data_wait);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Data::SM::wait} ...................................................*/
static QState Data_wait(Data * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Data::SM::wait::OTEMP} */
        case OTEMP_SIG: {
            QTimeEvt_rearm(&me->timer,  MESSAGE_PERIOD);

            Data_saveData(me,Q_EVT_CAST(ValEvt)->value, Q_EVT_CAST(ValEvt)->denom);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Data::SM::wait::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&Data_delay);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Data} ######################################################*/
