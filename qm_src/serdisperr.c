/*$file${qm_src::serdisperr.c} #############################################*/
/*
* Model: balkonowy_rx_ult_.qm
* File:  ${qm_src::serdisperr.c}
*
* This code has been generated by QM 4.3.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${qm_src::serdisperr.c} ##########################################*/
#include "qpc.h"
#include "bsp.h"
#include "project.h"
#include "serdisperr.h"
//#include "link-proto.h"
#include "led7seg.h"
#include "err.h"
#include "rerror.h"

Q_DEFINE_THIS_FILE

#define NANB ONE_QUESTION

//definicje symboli (poddefinicje są zdefinowane w bsp.h)
//Czas włączenia diody w razie wystąpienia błędów. W tikach
#define LED_ON    ERR_NOTICE_ON*BSP_TICKS_PER_SEC/1000
//Czas przerwy w błyskaniu LED w razie wystąpienia błędów. W tikach
#define LED_OFF   ERR_NOTICE_OFF*BSP_TICKS_PER_SEC/1000

/* local objects -----------------------------------------------------------*/

/*$declare${AOs::SerDispErr} ###############################################*/
/*${AOs::SerDispErr} .......................................................*/
typedef struct {
/* protected: */
    QHsm super;

/* private: */
    int16_t batt;
    uint8_t txHalt;
    uint8_t txErr;
    uint8_t err;
    QTimeEvt blinkEvt;
} SerDispErr;

/* protected: */
static QState SerDispErr_initial(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_container(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_idle(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_error(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_on(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_display(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_dsp_halt(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_dsp_txerr(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_dsp_err(SerDispErr * const me, QEvt const * const e);
static QState SerDispErr_dsp_batt(SerDispErr * const me, QEvt const * const e);
/*$enddecl${AOs::SerDispErr} ###############################################*/
static SerDispErr l_serDispErr; /* the sole instance of the SerDisp active object */


/* Public-scope objects ----------------------------------------------------*/

/* Active object definition ================================================*/

/* Check for the minimum required QP version */
#if (QP_VERSION < 630U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.3.0 or higher required
#endif

/*$define${AOs::SerDispErr_ctor} ###########################################*/
/*${AOs::SerDispErr_ctor} ..................................................*/
QHsm * SerDispErr_ctor(QActive * const superAO) {
    SerDispErr *me = &l_serDispErr;

    /* superclass' ctor */
    QHsm_ctor(&me->super, Q_STATE_CAST(&SerDispErr_initial));
    /* superAO will dispatch event down to me */
    QTimeEvt_ctorX(&me->blinkEvt, superAO, ORTHO_BLINK_SIG, HARD_TICKRATE_1);

    me->batt = NANB;
    me->txHalt = 0;
    me->txErr = 0;
    me->err = 0;

    return (QHsm *)me;
}
/*$enddef${AOs::SerDispErr_ctor} ###########################################*/
/*$define${AOs::SerDispErr} ################################################*/
/*${AOs::SerDispErr} .......................................................*/
/*${AOs::SerDispErr::SM} ...................................................*/
static QState SerDispErr_initial(SerDispErr * const me, QEvt const * const e) {
    /*${AOs::SerDispErr::SM::initial} */
    (void)e;

    QS_OBJ_DICTIONARY(&l_serDispErr);

    QS_FUN_DICTIONARY(&SerDispErr_container);
    QS_FUN_DICTIONARY(&SerDispErr_idle);
    QS_FUN_DICTIONARY(&SerDispErr_error);
    QS_FUN_DICTIONARY(&SerDispErr_on);
    QS_FUN_DICTIONARY(&SerDispErr_display);
    QS_FUN_DICTIONARY(&SerDispErr_dsp_halt);
    QS_FUN_DICTIONARY(&SerDispErr_dsp_txerr);
    QS_FUN_DICTIONARY(&SerDispErr_dsp_err);
    QS_FUN_DICTIONARY(&SerDispErr_dsp_batt);

    return Q_TRAN(&SerDispErr_idle);
}
/*${AOs::SerDispErr::SM::container} ........................................*/
static QState SerDispErr_container(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::BATT} */
        case BATT_SIG: {
            me->batt =  Q_EVT_CAST(ValEvt)->value;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDispErr::SM::container::TX_HALT} */
        case TX_HALT_SIG: {
            me->txHalt = 1;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDispErr::SM::container::TX_ERR} */
        case TX_ERR_SIG: {
            me->txErr |= Q_EVT_CAST(ErrEvt)->errCode;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDispErr::SM::container::ERR} */
        case ERR_SIG: {
            me->err |= Q_EVT_CAST(ErrEvt)->errCode;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDispErr::SM::container::BTN_PRSS} */
        case BTN_PRSS_SIG: {
            /*${AOs::SerDispErr::SM::container::BTN_PRSS::[halt]} */
            if (me->txHalt) {
                status_ = Q_TRAN(&SerDispErr_dsp_halt);
            }
            /*${AOs::SerDispErr::SM::container::BTN_PRSS::[else]} */
            else {
                /*${AOs::SerDispErr::SM::container::BTN_PRSS::[else]::[tx_err]} */
                if (me->txErr) {
                    status_ = Q_TRAN(&SerDispErr_dsp_txerr);
                }
                /*${AOs::SerDispErr::SM::container::BTN_PRSS::[else]::[else]} */
                else {
                    /*${AOs::SerDispErr::SM::container::BTN_PRSS::[else]::[else]::[err]} */
                    if (me->err) {
                        status_ = Q_TRAN(&SerDispErr_dsp_err);
                    }
                    /*${AOs::SerDispErr::SM::container::BTN_PRSS::[else]::[else]::[else]} */
                    else {
                        status_ = Q_TRAN(&SerDispErr_dsp_batt);
                    }
                }
            }
            break;
        }
        /*${AOs::SerDispErr::SM::container::BTN_REL} */
        case BTN_REL_SIG: {
            /*${AOs::SerDispErr::SM::container::BTN_REL::[is_error]} */
            if (me->txHalt || me->txErr || me->err) {
                status_ = Q_TRAN(&SerDispErr_on);
            }
            /*${AOs::SerDispErr::SM::container::BTN_REL::[else]} */
            else {
                status_ = Q_TRAN(&SerDispErr_idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::idle} ..................................*/
static QState SerDispErr_idle(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::idle::TX_HALT} */
        case TX_HALT_SIG: {
            me->txHalt = 1;
            status_ = Q_TRAN(&SerDispErr_on);
            break;
        }
        /*${AOs::SerDispErr::SM::container::idle::TX_ERR} */
        case TX_ERR_SIG: {
            me->txErr |= Q_EVT_CAST(ErrEvt)->errCode;
            status_ = Q_TRAN(&SerDispErr_on);
            break;
        }
        /*${AOs::SerDispErr::SM::container::idle::ERR} */
        case ERR_SIG: {
            me->err |= Q_EVT_CAST(ErrEvt)->errCode;
            status_ = Q_TRAN(&SerDispErr_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_container);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::error} .................................*/
static QState SerDispErr_error(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::error} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->blinkEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDispErr::SM::container::error::ORTHO_BLINK} */
        case ORTHO_BLINK_SIG: {
            status_ = Q_TRAN(&SerDispErr_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_container);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::error::on} .............................*/
static QState SerDispErr_on(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::error::on} */
        case Q_ENTRY_SIG: {
            led_notify_error(true);
            led_show();
            QTimeEvt_armX(&me->blinkEvt,  LED_ON, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDispErr::SM::container::error::on} */
        case Q_EXIT_SIG: {
            led_notify_error(false);
            led_show();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::SerDispErr::SM::container::error::on::ORTHO_BLINK} */
        case ORTHO_BLINK_SIG: {
            QTimeEvt_armX(&me->blinkEvt,  LED_OFF, 0U);
            status_ = Q_TRAN(&SerDispErr_error);
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_error);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::display} ...............................*/
static QState SerDispErr_display(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::display} */
        case Q_EXIT_SIG: {
            led_notify_error(false);
            led_show();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_container);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::display::dsp_halt} .....................*/
static QState SerDispErr_dsp_halt(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::display::dsp_halt} */
        case Q_ENTRY_SIG: {
            led_msg(HALT_MSG);
            led_notify_error(true);
            led_show();

            me->txHalt = 0;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_display);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::display::dsp_txerr} ....................*/
static QState SerDispErr_dsp_txerr(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::display::dsp_txerr} */
        case Q_ENTRY_SIG: {
            led_display_number(me->txErr, 16);
            //led_display_number((me->txErr)*-1, 16); //test
            led_notify_error(true);
            led_show();

            me->txErr = 0;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_display);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::display::dsp_err} ......................*/
static QState SerDispErr_dsp_err(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::display::dsp_err} */
        case Q_ENTRY_SIG: {
            //zmieniamy znak by włączyć LED MINUS
            led_display_number((me->err)*-1, 16);
            led_notify_error(true);
            led_show();

            //czyszczenie przyczyny błędu, który spowodował restart
            //Watchdog error nie potrzebuje czyszczenia,
            //Assert failed trzeba z kolei przeczytać w debugerze
            if( (me->err!=ERR_ASSERT_FAILED) && (me->err != ERR_WD_RESET))
                rerr_reset();

            me->err = 0;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_display);
            break;
        }
    }
    return status_;
}
/*${AOs::SerDispErr::SM::container::dsp_batt} ..............................*/
static QState SerDispErr_dsp_batt(SerDispErr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::SerDispErr::SM::container::dsp_batt} */
        case Q_ENTRY_SIG: {
            led_display_number(me->batt, 10);
            //led_notify_error(false);
            led_show();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SerDispErr_container);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::SerDispErr} ################################################*/
