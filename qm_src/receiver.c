/*$file${qm_src::receiver.c} ###############################################*/
/*
* Model: balkonowy_rx_ult_.qm
* File:  ${qm_src::receiver.c}
*
* This code has been generated by QM 4.3.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${qm_src::receiver.c} ############################################*/
#include <string.h>
#include "qpc.h"
#include "bsp.h"
//#include "app_conf.h"
#include "link-proto.h"
#include "VirtualWire.h"
//#include "datalog.h"
#include "project.h"
#include "receiver.h"


/*$declare${AOs::Rcv} ######################################################*/
/*${AOs::Rcv} ..............................................................*/
typedef struct {
/* protected: */
    QActive super;
} Rcv;

/* protected: */
static QState Rcv_initial(Rcv * const me, QEvt const * const e);
static QState Rcv_receiver(Rcv * const me, QEvt const * const e);
/*$enddecl${AOs::Rcv} ######################################################*/

/*$declare${AOs::RcvMsgDec} ################################################*/
/*${AOs::RcvMsgDec} ........................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */
    uint32_t lastTimestamp;
} RcvMsgDec;

/* private: */
static bool RcvMsgDec_hasIntervalElapsed(RcvMsgDec * const me, uint32_t timestamp);

/* protected: */
static QState RcvMsgDec_initial(RcvMsgDec * const me, QEvt const * const e);
static QState RcvMsgDec_decoder(RcvMsgDec * const me, QEvt const * const e);
/*$enddecl${AOs::RcvMsgDec} ################################################*/

/*$declare${AOs::RcvBatDec} ################################################*/
/*${AOs::RcvBatDec} ........................................................*/
typedef struct {
/* protected: */
    QActive super;
} RcvBatDec;

/* protected: */
static QState RcvBatDec_initial(RcvBatDec * const me, QEvt const * const e);
static QState RcvBatDec_decoder(RcvBatDec * const me, QEvt const * const e);
/*$enddecl${AOs::RcvBatDec} ################################################*/

/*$declare${AOs::RcvTempDec} ###############################################*/
/*${AOs::RcvTempDec} .......................................................*/
typedef struct {
/* protected: */
    QActive super;
} RcvTempDec;

/* protected: */
static QState RcvTempDec_initial(RcvTempDec * const me, QEvt const * const e);
static QState RcvTempDec_decoder(RcvTempDec * const me, QEvt const * const e);
/*$enddecl${AOs::RcvTempDec} ###############################################*/

static Rcv l_rcv;
QActive * const  AO_Rcv = &l_rcv.super;

static RcvMsgDec l_rcvMsgDec;
QActive * const AO_RcvMsgDec = &l_rcvMsgDec.super;

static RcvBatDec l_rcvBatDec;
QActive * const AO_RcvBatDec = &l_rcvBatDec.super;

static RcvTempDec l_rcvTempDec;
QActive * const AO_RcvTempDec = &l_rcvTempDec.super;

/* Check for the minimum required QP version */
#if (QP_VERSION < 630U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.3.0 or higher required
#endif

/*$define${AOs::Rcv_ctor} ##################################################*/
/*${AOs::Rcv_ctor} .........................................................*/
void Rcv_ctor(void) {
    Rcv * const me = &l_rcv;

    QActive_ctor(&me->super, Q_STATE_CAST(&Rcv_initial));

    //QMPool_init(    &msgPool,
    //                            memPoolSto,
    //                            sizeof(memPoolSto),
    //                            VW_MAX_MESSAGE_LEN);
}
/*$enddef${AOs::Rcv_ctor} ##################################################*/
/*$define${AOs::Rcv} #######################################################*/
/*${AOs::Rcv} ..............................................................*/
/*${AOs::Rcv::SM} ..........................................................*/
static QState Rcv_initial(Rcv * const me, QEvt const * const e) {
    /*${AOs::Rcv::SM::initial} */
    QActive_subscribe(&me->super, VW_SIG);
    (void)e;

    QS_OBJ_DICTIONARY(AO_Rcv);


    QS_FUN_DICTIONARY(&Rcv_receiver);

    return Q_TRAN(&Rcv_receiver);
}
/*${AOs::Rcv::SM::receiver} ................................................*/
static QState Rcv_receiver(Rcv * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Rcv::SM::receiver::VW} */
        case VW_SIG: {
            uint32_t timestamp = BSP_getTimestamp();
            uint8_t len = XDATA_PACKET_SIZE;
            uint8_t block[XDATA_PACKET_SIZE];

            /*${AOs::Rcv::SM::receiver::VW::[new_msg]} */
            if (vw_get_message(block, &len) &&
                isNotTrunc( block, len ) &&
                isIdTx( block, len))
            {

                QS_BEGIN(LOG_STAT,me)
                    QS_U32(0, timestamp);
                    QS_U8(0, len);
                    QS_MEM(block,len);
                QS_END()

                MsgEvt *pe = Q_NEW(MsgEvt, MSG_SIG);
                pe->timestamp = timestamp;
                pe->msgLen = len;
                memcpy(&pe->msg, block, len);

                //publikuj msg. komunikaty-powtórzenia także są publikowane
                //QF_PUBLISH((QEvt*)pe, me);
                QACTIVE_POST(AO_RcvMsgDec, (QEvt*)pe, me);

                status_ = Q_HANDLED();
            }
            /*${AOs::Rcv::SM::receiver::VW::[else]} */
            else {
                QS_BEGIN(VW_STAT, me) /* application-specific record begin */
                        QS_U8(1, len);
                        QS_MEM(block,XDATA_PACKET_SIZE);
                QS_END()
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Rcv} #######################################################*/

/*$define${AOs::RcvMsgDec_ctor} ############################################*/
/*${AOs::RcvMsgDec_ctor} ...................................................*/
void RcvMsgDec_ctor(void) {
    RcvMsgDec * const me = &l_rcvMsgDec;

    QActive_ctor(&me->super, Q_STATE_CAST(&RcvMsgDec_initial));

}
/*$enddef${AOs::RcvMsgDec_ctor} ############################################*/
/*$define${AOs::RcvMsgDec} #################################################*/
/*${AOs::RcvMsgDec} ........................................................*/
/*${AOs::RcvMsgDec::hasIntervalElapsed} ....................................*/
static bool RcvMsgDec_hasIntervalElapsed(RcvMsgDec * const me, uint32_t timestamp) {
    return ( ((timestamp) - (me->lastTimestamp)) > (2*BSP_MSG_INTERVAL*BSP_TIMESTAMP_TICKS_PER_SEC));
}

/*${AOs::RcvMsgDec::SM} ....................................................*/
static QState RcvMsgDec_initial(RcvMsgDec * const me, QEvt const * const e) {
    /*${AOs::RcvMsgDec::SM::initial} */
    //QActive_subscribe(&me->super, MSG_SIG);

    me->lastTimestamp = 0;
    (void)e;

    QS_OBJ_DICTIONARY(AO_RcvMsgDec);

    QS_FUN_DICTIONARY(&RcvMsgDec_decoder);

    return Q_TRAN(&RcvMsgDec_decoder);
}
/*${AOs::RcvMsgDec::SM::decoder} ...........................................*/
static QState RcvMsgDec_decoder(RcvMsgDec * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::RcvMsgDec::SM::decoder::MSG} */
        case MSG_SIG: {
            /*${AOs::RcvMsgDec::SM::decoder::MSG::[new_msg]} */
            if (isNewMsg(Q_EVT_CAST(MsgEvt)->msg,
                        Q_EVT_CAST(MsgEvt)->msgLen)
                ||  RcvMsgDec_hasIntervalElapsed(me,Q_EVT_CAST(MsgEvt)-> timestamp))
            {

                me->lastTimestamp = Q_EVT_CAST(MsgEvt)-> timestamp;

                /*${AOs::RcvMsgDec::SM::decoder::MSG::[new_msg]::[not_halt]} */
                if (! isHalt(    Q_EVT_CAST(MsgEvt)->msg,
                                    Q_EVT_CAST(MsgEvt)->msgLen))
                {

                    //przekaż komunikat do zdekodowania napięcia baterii
                    QACTIVE_POST(AO_RcvBatDec, (QEvt*)e, me);

                    uint8_t errCode =
                            getErr( ((MsgEvt const *)e)->msg,
                                    ((MsgEvt const*)e)->msgLen);

                    /*${AOs::RcvMsgDec::SM::decoder::MSG::[new_msg]::[not_halt]::[tx_err]} */
                    if (errCode) {

                        //Tx Error
                        ErrEvt *pe = Q_NEW(ErrEvt, TX_ERR_SIG);
                        pe->errCode = errCode;
                        QF_PUBLISH((QEvt*)pe, me);

                        /*${AOs::RcvMsgDec::SM::decoder::MSG::[new_msg]::[not_halt]::[tx_err]::[not_value_err]} */
                        if (! isValErr( Q_EVT_CAST(MsgEvt)->msg,
                                                          Q_EVT_CAST(MsgEvt)->msgLen))
                        {
                            //błędy związane z resetem nie wpływają na prawidłowość
                            //odczytu czujnika
                            QACTIVE_POST(AO_RcvTempDec, (QEvt*)e, me);
                            status_ = Q_HANDLED();
                        }
                        /*${AOs::RcvMsgDec::SM::decoder::MSG::[new_msg]::[not_halt]::[tx_err]::[else]} */
                        else {

                            QS_BEGIN(VALERR_STAT,me)
                                QS_U8(0, errCode);
                            QS_END()

                            //błędy związane z magistralą 1wire unieważniają wartość
                            //temperatury przesłaną w komunikacie
                            status_ = Q_HANDLED();
                        }
                    }
                    /*${AOs::RcvMsgDec::SM::decoder::MSG::[new_msg]::[not_halt]::[else]} */
                    else {
                        QACTIVE_POST(AO_RcvTempDec, (QEvt*)e, me);
                        status_ = Q_HANDLED();
                    }
                }
                /*${AOs::RcvMsgDec::SM::decoder::MSG::[new_msg]::[else]} */
                else {
                    QS_BEGIN(HALT_STAT,me)
                        QS_U32(0, Q_EVT_CAST(MsgEvt)-> timestamp);
                        QS_U8(0, Q_EVT_CAST(MsgEvt)->msgLen);
                        QS_MEM(Q_EVT_CAST(MsgEvt)->msg,Q_EVT_CAST(MsgEvt)->msgLen);
                    QS_END()

                    QF_PUBLISH(Q_NEW(QEvt,TX_HALT_SIG), me);

                    //jeśli HALT wartości baterii i temperatury nie mają
                    // znaczenia
                    status_ = Q_HANDLED();
                }
            }
            /*${AOs::RcvMsgDec::SM::decoder::MSG::[else]} */
            else {
                QS_BEGIN(DUP_STAT,me)
                    QS_U32(0, Q_EVT_CAST(MsgEvt)-> timestamp);
                    QS_U8(0, Q_EVT_CAST(MsgEvt)->msgLen);
                    QS_MEM(Q_EVT_CAST(MsgEvt)->msg,Q_EVT_CAST(MsgEvt)->msgLen);
                QS_END()

                //MsgEvt *pe = Q_NEW(QEvt, DUPLICATE_SIG);

                //publikuj msg
                //QF_PUBLISH((QEvt*)pe, me);
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::RcvMsgDec} #################################################*/

/*$define${AOs::RcvBatDec_ctor} ############################################*/
/*${AOs::RcvBatDec_ctor} ...................................................*/
void RcvBatDec_ctor(void) {
    RcvBatDec * const me = &l_rcvBatDec;

    QActive_ctor(&me->super, Q_STATE_CAST(&RcvBatDec_initial));

}
/*$enddef${AOs::RcvBatDec_ctor} ############################################*/
/*$define${AOs::RcvBatDec} #################################################*/
/*${AOs::RcvBatDec} ........................................................*/
/*${AOs::RcvBatDec::SM} ....................................................*/
static QState RcvBatDec_initial(RcvBatDec * const me, QEvt const * const e) {
    /*${AOs::RcvBatDec::SM::initial} */
    (void)e;

    QS_OBJ_DICTIONARY(AO_RcvBatDec);

    QS_FUN_DICTIONARY(&RcvBatDec_decoder);

    return Q_TRAN(&RcvBatDec_decoder);
}
/*${AOs::RcvBatDec::SM::decoder} ...........................................*/
static QState RcvBatDec_decoder(RcvBatDec * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::RcvBatDec::SM::decoder::MSG} */
        case MSG_SIG: {
            int16_t value;
            uint8_t denom;

            getBatt(    ((MsgEvt const *)e)->msg,
                              ((MsgEvt const *)e)->msgLen,
                               &value,
                               &denom );
            ValEvt *pe = Q_NEW(ValEvt, BATT_SIG);
            pe->value = value;
            pe->denom = denom;

            QF_PUBLISH((QEvt*)pe, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::RcvBatDec} #################################################*/

/*$define${AOs::RcvTempDec_ctor} ###########################################*/
/*${AOs::RcvTempDec_ctor} ..................................................*/
void RcvTempDec_ctor(void) {
    RcvTempDec * const me = &l_rcvTempDec;

    QActive_ctor(&me->super, Q_STATE_CAST(&RcvTempDec_initial));

}
/*$enddef${AOs::RcvTempDec_ctor} ###########################################*/
/*$define${AOs::RcvTempDec} ################################################*/
/*${AOs::RcvTempDec} .......................................................*/
/*${AOs::RcvTempDec::SM} ...................................................*/
static QState RcvTempDec_initial(RcvTempDec * const me, QEvt const * const e) {
    /*${AOs::RcvTempDec::SM::initial} */
    (void)e;

    QS_OBJ_DICTIONARY(AO_RcvTempDec);

    QS_FUN_DICTIONARY(&RcvTempDec_decoder);

    return Q_TRAN(&RcvTempDec_decoder);
}
/*${AOs::RcvTempDec::SM::decoder} ..........................................*/
static QState RcvTempDec_decoder(RcvTempDec * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::RcvTempDec::SM::decoder::MSG} */
        case MSG_SIG: {
            int16_t value;
            uint8_t denom;

            getTemp(     ((MsgEvt const *)e)->msg,
                                      ((MsgEvt const *)e)->msgLen,
                                        &value,
                                        &denom );
            ValEvt *pe = Q_NEW(ValEvt, OTEMP_SIG);
            pe->value = value;
            pe->denom = denom;

            QF_PUBLISH((QEvt*)pe, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::RcvTempDec} ################################################*/
