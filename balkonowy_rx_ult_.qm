<?xml version="1.0" encoding="UTF-8"?>
<model version="4.3.0" links="0">
 <documentation>Model for temometer receiver</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="ErrEvt" superclass="qpc::QEvt">
   <attribute name="errCode" type="uint8_t" visibility="0x02" properties="0x00"/>
  </class>
  <class name="ValEvt" superclass="qpc::QEvt">
   <attribute name="value" type="int16_t" visibility="0x02" properties="0x00">
    <documentation>Wartość z przecinkiem przesuniętym o denom</documentation>
   </attribute>
   <attribute name="denom" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>O ile miejsc jest przesuniety przecinek w value</documentation>
   </attribute>
  </class>
  <class name="MsgEvt" superclass="qpc::QEvt">
   <attribute name="timestamp" type="uint32_t" visibility="0x00" properties="0x00"/>
   <attribute name="msgLen" type="uint8_t" visibility="0x00" properties="0x00"/>
   <attribute name="msg[XDATA_PACKET_SIZE]" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="Rcv" superclass="qpc::QActive">
   <documentation>Odbiera pełen komunikat, sprawdza Id i jeśli jest zgody pcha mesydż dalej</documentation>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1">
     <action>QActive_subscribe(&amp;me-&gt;super, VW_SIG);
(void)e;

QS_OBJ_DICTIONARY(AO_Rcv);
</action>
     <initial_glyph conn="16,3,5,0,3,3">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="receiver">
     <tran trig="VW">
      <action>uint32_t timestamp = BSP_getTimestamp();
uint8_t len = XDATA_PACKET_SIZE;
uint8_t block[XDATA_PACKET_SIZE];
</action>
      <choice>
       <guard brief="new_msg">vw_get_message(block, &amp;len) &amp;&amp; 
isNotTrunc( block, len ) &amp;&amp;
isIdTx( block, len)</guard>
       <action brief="post_msg">
QS_BEGIN(LOG_STAT,me)
    QS_U32(0, timestamp); 
    QS_U8(0, len); 
    QS_MEM(block,len); 
QS_END()   

MsgEvt *pe = Q_NEW(MsgEvt, MSG_SIG);
pe-&gt;timestamp = timestamp;
pe-&gt;msgLen = len;
memcpy(&amp;pe-&gt;msg, block, len);

//publikuj msg. komunikaty-powtórzenia także są publikowane
//QF_PUBLISH((QEvt*)pe, me);
QACTIVE_POST(AO_RcvMsgDec, (QEvt*)pe, me);
</action>
       <choice_glyph conn="15,17,5,-1,22">
        <action box="2,-3,24,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard brief="else"/>
       <action brief="qspy_log">QS_BEGIN(VW_STAT, me) /* application-specific record begin */
        QS_U8(1, len);
        QS_MEM(block,XDATA_PACKET_SIZE);
QS_END()  </action>
       <choice_glyph conn="15,17,4,-1,9,21">
        <action box="2,6,15,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="7,17,3,-1,8">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="7,6,38,31"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="RcvMsgDec" superclass="qpc::QActive">
   <documentation>Dekoduje odbebrany komunikat i generuje stosowne sygnały</documentation>
   <attribute name="lastTimestamp" type="uint32_t" visibility="0x00" properties="0x00">
    <documentation>Timestamp ostatnio odebranego nowego komunikatu</documentation>
   </attribute>
   <operation name="hasIntervalElapsed" type="bool" visibility="0x02" properties="0x00">
    <parameter name="timestamp" type="uint32_t"/>
    <code>return ( ((timestamp) - (me-&gt;lastTimestamp)) &gt; (2*BSP_MSG_INTERVAL*BSP_TIMESTAMP_TICKS_PER_SEC));</code>
   </operation>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1">
     <action>//QActive_subscribe(&amp;me-&gt;super, MSG_SIG);

me-&gt;lastTimestamp = 0;
(void)e;

QS_OBJ_DICTIONARY(AO_RcvMsgDec);</action>
     <initial_glyph conn="8,3,5,0,9,3">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="decoder">
     <tran trig="MSG">
      <choice>
       <guard brief="else"/>
       <action brief="pub_duplicate">QS_BEGIN(DUP_STAT,me)
    QS_U32(0, Q_EVT_CAST(MsgEvt)-&gt; timestamp); 
    QS_U8(0, Q_EVT_CAST(MsgEvt)-&gt;msgLen); 
    QS_MEM(Q_EVT_CAST(MsgEvt)-&gt;msg,Q_EVT_CAST(MsgEvt)-&gt;msgLen); 
QS_END()   

//MsgEvt *pe = Q_NEW(QEvt, DUPLICATE_SIG);

//publikuj msg
//QF_PUBLISH((QEvt*)pe, me);</action>
       <choice_glyph conn="14,12,5,-1,12">
        <action box="4,-3,19,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard brief="new_msg">isNewMsg(Q_EVT_CAST(MsgEvt)-&gt;msg,
        Q_EVT_CAST(MsgEvt)-&gt;msgLen)
||  RcvMsgDec_hasIntervalElapsed(me,Q_EVT_CAST(MsgEvt)-&gt; timestamp)</guard>
       <action>
me-&gt;lastTimestamp = Q_EVT_CAST(MsgEvt)-&gt; timestamp;
</action>
       <choice>
        <guard brief="else"/>
        <action brief="pub_halt">QS_BEGIN(HALT_STAT,me)
    QS_U32(0, Q_EVT_CAST(MsgEvt)-&gt; timestamp); 
    QS_U8(0, Q_EVT_CAST(MsgEvt)-&gt;msgLen); 
    QS_MEM(Q_EVT_CAST(MsgEvt)-&gt;msg,Q_EVT_CAST(MsgEvt)-&gt;msgLen); 
QS_END()   

QF_PUBLISH(Q_NEW(QEvt,TX_HALT_SIG), me);

//jeśli HALT wartości baterii i temperatury nie mają 
// znaczenia</action>
        <choice_glyph conn="14,20,5,-1,12">
         <action box="5,-3,18,2"/>
        </choice_glyph>
       </choice>
       <choice>
        <guard brief="not_halt">! isHalt(    Q_EVT_CAST(MsgEvt)-&gt;msg, 
                Q_EVT_CAST(MsgEvt)-&gt;msgLen)</guard>
        <action brief="pub_batt">
//przekaż komunikat do zdekodowania napięcia baterii
QACTIVE_POST(AO_RcvBatDec, (QEvt*)e, me);

uint8_t errCode = 
        getErr( ((MsgEvt const *)e)-&gt;msg, 
                ((MsgEvt const*)e)-&gt;msgLen);
</action>
        <choice>
         <guard brief="else"/>
         <action brief="pub_tmp">QACTIVE_POST(AO_RcvTempDec, (QEvt*)e, me);</action>
         <choice_glyph conn="14,28,5,-1,12">
          <action box="5,-3,17,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="tx_err">errCode</guard>
         <action brief="pub_tx_err">
//Tx Error
ErrEvt *pe = Q_NEW(ErrEvt, TX_ERR_SIG);
pe-&gt;errCode = errCode;
QF_PUBLISH((QEvt*)pe, me);
</action>
         <choice>
          <guard brief="else"/>
          <action brief="discard_temp_val">
QS_BEGIN(VALERR_STAT,me)
    QS_U8(0, errCode); 
QS_END()   

//błędy związane z magistralą 1wire unieważniają wartość
//temperatury przesłaną w komunikacie</action>
          <choice_glyph conn="14,37,5,-1,12">
           <action box="5,-2,19,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="not_value_err">! isValErr( Q_EVT_CAST(MsgEvt)-&gt;msg,
                              Q_EVT_CAST(MsgEvt)-&gt;msgLen)</guard>
          <action brief="pub_tmp">//błędy związane z resetem nie wpływają na prawidłowość
//odczytu czujnika
QACTIVE_POST(AO_RcvTempDec, (QEvt*)e, me);</action>
          <choice_glyph conn="14,37,4,-1,8,13">
           <action box="0,3,22,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="14,28,4,-1,9">
          <action box="0,3,18,2"/>
         </choice_glyph>
        </choice>
        <choice_glyph conn="14,20,4,-1,8">
         <action box="0,2,15,2"/>
        </choice_glyph>
       </choice>
       <choice_glyph conn="14,12,4,-1,8">
        <action box="0,2,16,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="5,12,3,-1,9">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="5,6,34,42"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="RcvBatDec" superclass="qpc::QActive">
   <statechart properties="QS_FUN_DICT">
    <initial target="../1">
     <action>(void)e;

QS_OBJ_DICTIONARY(AO_RcvBatDec);</action>
     <initial_glyph conn="19,8,5,0,1,7">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="decoder">
     <tran trig="MSG">
      <action>int16_t value;
uint8_t denom;

getBatt(    ((MsgEvt const *)e)-&gt;msg, 
                  ((MsgEvt const *)e)-&gt;msgLen,
                   &amp;value,
                   &amp;denom );
ValEvt *pe = Q_NEW(ValEvt, BATT_SIG);
pe-&gt;value = value;
pe-&gt;denom = denom;

QF_PUBLISH((QEvt*)pe, me);</action>
      <tran_glyph conn="9,30,3,-1,19">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="9,15,28,23"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="RcvTempDec" superclass="qpc::QActive">
   <statechart properties="QS_FUN_DICT">
    <initial target="../1">
     <action>(void)e;

QS_OBJ_DICTIONARY(AO_RcvTempDec);</action>
     <initial_glyph conn="22,4,5,0,-4,8">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="decoder">
     <tran trig="MSG">
      <action>int16_t value;
uint8_t denom;

getTemp(     ((MsgEvt const *)e)-&gt;msg, 
                          ((MsgEvt const *)e)-&gt;msgLen,
                            &amp;value,
                            &amp;denom );
ValEvt *pe = Q_NEW(ValEvt, OTEMP_SIG);
pe-&gt;value = value;
pe-&gt;denom = denom;

QF_PUBLISH((QEvt*)pe, me);</action>
      <tran_glyph conn="9,20,3,-1,13">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="9,12,18,13"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="SerDisp" superclass="qpc::QActive">
   <documentation>Obsługa wyświetlacza 7 segm. na SCT2024</documentation>
   <attribute name="timeoutEvt" type="QTimeEvt" visibility="0x02" properties="0x00">
    <documentation>Odmierzanie czasu ważności wyświetlanej temperatury</documentation>
   </attribute>
   <attribute name="blinkEvt" type="QTimeEvt" visibility="0x02" properties="0x00">
    <documentation>Miganie wyświetlacza dla wartości temperatury otrzymanej dawno</documentation>
   </attribute>
   <attribute name="lastRoundTemp" type="int16_t" visibility="0x02" properties="0x00"/>
   <attribute name="orthoCompPtr" type="QHsm *" visibility="0x02" properties="0x00"/>
   <attribute name="minmaxOrthoPtr" type="QHsm *" visibility="0x02" properties="0x00"/>
   <operation name="roundValue" type="int16_t" visibility="0x02" properties="0x00">
    <parameter name="val" type="int16_t"/>
    <parameter name="den" type="uint8_t"/>
    <code>(void)me;
uint16_t value, rest=0;
bool subzero = false;

/* to not to lose special symbols coded out of range of variable*/
if(val&gt;SPEC_SIGNS_GUARD)
    return val;

if(val == INT16_MIN)
{
    value = INT16_MAX + 1U;
}
else if( val&lt;0 )
{
    value = - val;
    subzero = true;
}
else
    value = val;

while(den--)
{
    rest = value % 10;
    value /= 10;
}

value += (rest&gt;=5);
if( !value &amp;&amp; subzero ) return ZERO_MINUS; /* that's right! */
//return ((val&lt;0)?-value:value);
return (subzero?-value:value);
</code>
   </operation>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1">
     <action>(void)e;

QHSM_INIT(me-&gt;orthoCompPtr, (QEvt *)0);
QHSM_INIT(me-&gt;minmaxOrthoPtr, (QEvt *)0);

QActive_subscribe(&amp;me-&gt;super, OTEMP_SIG);
QActive_subscribe(&amp;me-&gt;super, BATT_SIG);
QActive_subscribe(&amp;me-&gt;super, TX_ERR_SIG);
QActive_subscribe(&amp;me-&gt;super, ERR_SIG);
QActive_subscribe(&amp;me-&gt;super, TX_HALT_SIG);

QActive_subscribe(&amp;me-&gt;super, BTN_PRSS_SIG);
QActive_subscribe(&amp;me-&gt;super, BTN_REL_SIG);

QActive_subscribe(&amp;me-&gt;super, MIN_TEMP_SIG);
QActive_subscribe(&amp;me-&gt;super, MAX_TEMP_SIG);
QActive_subscribe(&amp;me-&gt;super, BTN_SHORT_SIG);


me-&gt;lastRoundTemp = NAN;

QS_OBJ_DICTIONARY(AO_SerDisp);</action>
     <initial_glyph conn="8,2,5,0,12,3">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="display">
     <initial target="../12">
      <initial_glyph conn="11,36,5,0,7,3">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <tran trig="TX_HALT">
      <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
      <tran_glyph conn="7,10,3,-1,18">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TX_ERR">
      <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
      <tran_glyph conn="7,12,3,-1,18">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="ERR">
      <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
      <tran_glyph conn="7,14,3,-1,18">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="BATT">
      <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
      <tran_glyph conn="7,16,3,-1,18">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="ORTHO_BLINK">
      <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
      <tran_glyph conn="7,18,3,-1,22">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <tran trig="OTEMP">
      <action brief="save,(re)arm">me-&gt;lastRoundTemp =
        SerDisp_roundValue(me,
                Q_EVT_CAST(ValEvt)-&gt;value,
                Q_EVT_CAST(ValEvt)-&gt;denom);


QTimeEvt_rearm(&amp;me-&gt;timeoutEvt,  ASSUME_AGED);
</action>
      <tran_glyph conn="7,32,3,-1,24">
       <action box="0,-2,19,2"/>
      </tran_glyph>
     </tran>
     <tran trig="MINMAX_TIMEOUT">
      <action brief="forward">QHSM_DISPATCH(me-&gt;minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */</action>
      <tran_glyph conn="7,26,3,-1,22">
       <action box="0,-2,22,2"/>
      </tran_glyph>
     </tran>
     <tran trig="MIN_TEMP">
      <action brief="round,forward">ValEvt pe = { {MIN_TEMP_SIG, 0, 0}, 0, 0 };

pe.value =
    SerDisp_roundValue(me,
            Q_EVT_CAST(ValEvt)-&gt;value,
            Q_EVT_CAST(ValEvt)-&gt;denom);


QHSM_DISPATCH(me-&gt;minmaxOrthoPtr, (QEvt *)&amp;pe); /* direct dispatch */</action>
      <tran_glyph conn="7,22,3,-1,22">
       <action box="0,-2,19,2"/>
      </tran_glyph>
     </tran>
     <tran trig="MAX_TEMP">
      <action brief="round forward">ValEvt pe = { {MAX_TEMP_SIG, 0, 0}, 0, 0 };

pe.value =
    SerDisp_roundValue(me,
            Q_EVT_CAST(ValEvt)-&gt;value,
            Q_EVT_CAST(ValEvt)-&gt;denom);


QHSM_DISPATCH(me-&gt;minmaxOrthoPtr, (QEvt *)&amp;pe); /* direct dispatch */</action>
      <tran_glyph conn="7,24,3,-1,22">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <state name="blink">
      <entry brief="arm period">QTimeEvt_armX(&amp;me-&gt;blinkEvt,  BLINK_DISPLAY, BLINK_DISPLAY);</entry>
      <exit brief="disarm">QTimeEvt_disarm(&amp;me-&gt;blinkEvt);</exit>
      <initial target="../6">
       <initial_glyph conn="51,42,4,3,4,3">
        <action box="0,-2,10,2"/>
       </initial_glyph>
      </initial>
      <tran trig="TIMEOUT" target="../../12">
       <action brief="save nan">me-&gt;lastRoundTemp = NAN;</action>
       <tran_glyph conn="49,53,3,1,-15">
        <action box="-15,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="BTN_PRSS" target="../../11/2">
       <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
       <tran_glyph conn="56,63,2,0,14">
        <action box="-6,-2,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="OTEMP" target="../../12">
       <action brief="save,rearm">
me-&gt;lastRoundTemp =
    SerDisp_roundValue(me,
            Q_EVT_CAST(ValEvt)-&gt;value,
            Q_EVT_CAST(ValEvt)-&gt;denom);

QTimeEvt_rearm(&amp;me-&gt;timeoutEvt,  ASSUME_AGED);
</action>
       <tran_glyph conn="49,56,3,1,-15">
        <action box="-15,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="BTN_SHORT" target="../../13/3">
       <action brief="forward">QHSM_DISPATCH(me-&gt;minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */</action>
       <tran_glyph conn="70,63,2,0,41">
        <action box="-4,-2,18,2"/>
       </tran_glyph>
      </tran>
      <state name="blink_on">
       <entry brief="update saved">led_display_number(me-&gt;lastRoundTemp, 10);
led_show();</entry>
       <tran trig="DISP_BLINK" target="../../6">
        <tran_glyph conn="66,37,1,1,4,13,-4">
         <action box="-11,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="54,28,12,13">
        <entry box="1,2,10,4"/>
       </state_glyph>
      </state>
      <state name="blink_off">
       <entry brief="update empty">led_clear_buff();
led_show();</entry>
       <tran trig="DISP_BLINK" target="../../5">
        <tran_glyph conn="66,54,1,1,6,-21,-6">
         <action box="-11,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="54,44,12,14">
        <entry box="1,2,10,4"/>
       </state_glyph>
      </state>
      <state_glyph node="49,20,25,43">
       <entry box="1,2,7,2"/>
       <exit box="1,4,10,2"/>
      </state_glyph>
     </state>
     <state name="handover">
      <documentation>sterowanie wyświetlaczem przekazane do komponentu ortogonalnego</documentation>
      <tran trig="TIMEOUT" target="../2">
       <action brief="arm">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  ASSUME_OUTDATED-ASSUME_AGED, 0U);</action>
       <tran_glyph conn="21,81,3,3,19">
        <action box="0,-2,13,2"/>
       </tran_glyph>
      </tran>
      <tran trig="BTN_REL" target="../../12">
       <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
       <tran_glyph conn="32,70,0,2,-7">
        <action box="-3,2,16,2"/>
       </tran_glyph>
      </tran>
      <state name="handover_blink">
       <documentation>sterowanie wyświetlaczem przekazane do komponentu ortogonalnego</documentation>
       <tran trig="BTN_REL" target="../../../10">
        <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
        <tran_glyph conn="60,77,0,2,-14">
         <action box="-8,2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="TIMEOUT" target="../..">
        <action brief="save nan">me-&gt;lastRoundTemp = NAN;</action>
        <tran_glyph conn="40,84,3,3,-19">
         <action box="-9,-2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="OTEMP" target="../..">
        <action brief="save,rearm">
me-&gt;lastRoundTemp =
    SerDisp_roundValue(me,
            Q_EVT_CAST(ValEvt)-&gt;value,
            Q_EVT_CAST(ValEvt)-&gt;denom);

QTimeEvt_rearm(&amp;me-&gt;timeoutEvt,  ASSUME_AGED);
</action>
        <tran_glyph conn="40,87,3,3,-19">
         <action box="-9,-2,15,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="40,77,23,13"/>
      </state>
      <state_glyph node="21,70,47,23"/>
     </state>
     <state name="run">
      <entry brief="update">
led_display_number(me-&gt;lastRoundTemp, 10);
led_show();
</entry>
      <tran trig="BTN_PRSS" target="../../11">
       <action brief="forward">QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
       <tran_glyph conn="28,63,2,0,7">
        <action box="-7,-3,18,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TIMEOUT" target="../../10">
       <action brief="arm">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  ASSUME_OUTDATED-ASSUME_AGED, 0U);</action>
       <tran_glyph conn="34,51,1,3,15">
        <action box="0,-2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="OTEMP">
       <action brief="(re)arm, save, update">
//timer może być uzbrojony lub nie
QTimeEvt_rearm(&amp;me-&gt;timeoutEvt,  ASSUME_AGED);

me-&gt;lastRoundTemp = SerDisp_roundValue(me,
            Q_EVT_CAST(ValEvt)-&gt;value,
            Q_EVT_CAST(ValEvt)-&gt;denom);

//aktualizuj wyświetlacz
led_display_number(me-&gt;lastRoundTemp, 10);
led_show();
</action>
       <tran_glyph conn="12,47,3,-1,19">
        <action box="0,-2,22,2"/>
       </tran_glyph>
      </tran>
      <tran trig="BTN_SHORT" target="../../13">
       <action brief="forward">QHSM_DISPATCH(me-&gt;minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */</action>
       <tran_glyph conn="14,63,2,0,36">
        <action box="-7,-2,18,3"/>
       </tran_glyph>
      </tran>
      <state_glyph node="12,39,22,24">
       <entry box="1,2,10,2"/>
      </state_glyph>
     </state>
     <state name="minimax">
      <tran trig="RET_ORTHO" target="../../12">
       <tran_glyph conn="16,99,0,2,-36">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TIMEOUT" target="../3">
       <action brief="arm">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  ASSUME_OUTDATED-ASSUME_AGED, 0U);</action>
       <tran_glyph conn="11,112,3,3,39">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <tran trig="BTN_PRSS" target="../../11">
       <action brief="forward">QHSM_DISPATCH(me-&gt;minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */
QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
       <tran_glyph conn="29,99,0,2,-6">
        <action box="0,-2,17,2"/>
       </tran_glyph>
      </tran>
      <state name="minimax_blink">
       <tran trig="RET_ORTHO" target="../../../10">
        <tran_glyph conn="72,104,0,2,-41">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="OTEMP" target="../..">
        <action brief="save, rearm">
me-&gt;lastRoundTemp =
    SerDisp_roundValue(me,
            Q_EVT_CAST(ValEvt)-&gt;value,
            Q_EVT_CAST(ValEvt)-&gt;denom);

QTimeEvt_rearm(&amp;me-&gt;timeoutEvt,  ASSUME_AGED);
</action>
        <tran_glyph conn="50,118,3,3,-39">
         <action box="-16,-2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="TIMEOUT" target="../..">
        <action brief="save nan">me-&gt;lastRoundTemp = NAN;</action>
        <tran_glyph conn="50,115,3,3,-39">
         <action box="-16,-2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="BTN_PRSS" target="../../../11/2">
        <action brief="forward">QHSM_DISPATCH(me-&gt;minmaxOrthoPtr, (QEvt *)e); /* direct dispatch */
QHSM_DISPATCH(me-&gt;orthoCompPtr, (QEvt *)e); /* direct dispatch */</action>
        <tran_glyph conn="54,104,0,2,-14">
         <action box="0,-2,15,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="50,104,25,15"/>
      </state>
      <state_glyph node="11,99,66,23"/>
     </state>
     <state_glyph node="7,5,72,119"/>
    </state>
    <state_diagram size="84,126"/>
   </statechart>
  </class>
  <class name="SerDispErr" superclass="qpc::QHsm">
   <documentation>Orthogonal component of AO SerDisp realizing singalization and display of errors and battery level of transmitter and errors of receiver.</documentation>
   <attribute name="batt" type="int16_t" visibility="0x02" properties="0x00"/>
   <attribute name="txHalt" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="txErr" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="err" type="uint8_t" visibility="0x02" properties="0x00"/>
   <attribute name="blinkEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1/6">
     <action>(void)e;

QS_OBJ_DICTIONARY(&amp;l_serDispErr);</action>
     <initial_glyph conn="3,2,4,3,23,6">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="container">
     <tran trig="BATT">
      <action brief="save">me-&gt;batt =  Q_EVT_CAST(ValEvt)-&gt;value;</action>
      <tran_glyph conn="6,8,3,-1,17">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TX_HALT">
      <action brief="save">me-&gt;txHalt = 1;</action>
      <tran_glyph conn="6,10,3,-1,17">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TX_ERR">
      <action brief="save">me-&gt;txErr |= Q_EVT_CAST(ErrEvt)-&gt;errCode;</action>
      <tran_glyph conn="6,12,3,-1,17">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="ERR">
      <action brief="save">me-&gt;err |= Q_EVT_CAST(ErrEvt)-&gt;errCode;</action>
      <tran_glyph conn="6,14,3,-1,17">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="BTN_PRSS">
      <choice target="../../8/0">
       <guard brief="halt">me-&gt;txHalt</guard>
       <choice_glyph conn="16,55,5,3,10">
        <action box="1,-2,26,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard brief="else"/>
       <choice target="../../../8/1">
        <guard brief="tx_err">me-&gt;txErr</guard>
        <choice_glyph conn="16,63,5,3,10">
         <action box="1,-2,29,2"/>
        </choice_glyph>
       </choice>
       <choice>
        <guard brief="else"/>
        <choice target="../../../../8/2">
         <guard brief="err">me-&gt;err</guard>
         <choice_glyph conn="16,70,5,3,10">
          <action box="1,-2,26,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../9">
         <guard brief="else"/>
         <choice_glyph conn="16,70,4,3,8,10">
          <action box="0,5,25,2"/>
         </choice_glyph>
        </choice>
        <choice_glyph conn="16,63,4,-1,7">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <choice_glyph conn="16,55,4,-1,8">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="6,55,3,-1,10">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="BTN_REL">
      <choice target="../../7/1">
       <guard brief="is_error">me-&gt;txHalt || me-&gt;txErr || me-&gt;err</guard>
       <choice_glyph conn="16,40,5,3,17">
        <action box="2,-2,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../6">
       <guard brief="else"/>
       <choice_glyph conn="16,40,4,2,-6">
        <action box="0,-5,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="6,40,3,-1,10">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="idle">
      <tran trig="TX_HALT" target="../../7/1">
       <action brief="save">me-&gt;txHalt = 1;</action>
       <tran_glyph conn="22,26,1,3,11">
        <action box="-12,-2,12,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TX_ERR" target="../../7/1">
       <action brief="save">me-&gt;txErr |= Q_EVT_CAST(ErrEvt)-&gt;errCode;</action>
       <tran_glyph conn="22,29,1,3,11">
        <action box="-12,-2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="ERR" target="../../7/1">
       <action brief="save">me-&gt;err |= Q_EVT_CAST(ErrEvt)-&gt;errCode;</action>
       <tran_glyph conn="22,32,1,3,11">
        <action box="-12,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="9,21,13,13"/>
     </state>
     <state name="error">
      <exit brief="disarm">QTimeEvt_disarm(&amp;me-&gt;blinkEvt);</exit>
      <tran trig="ORTHO_BLINK" target="../1">
       <tran_glyph conn="60,27,1,1,-11">
        <action box="-11,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state name="on">
       <entry brief="arm once, led on">led_notify_error(true);
led_show();
QTimeEvt_armX(&amp;me-&gt;blinkEvt,  LED_ON, 0U);</entry>
       <exit brief="led off">led_notify_error(false);
led_show();</exit>
       <tran trig="ORTHO_BLINK" target="../..">
        <action brief="arm once">QTimeEvt_armX(&amp;me-&gt;blinkEvt,  LED_OFF, 0U);</action>
        <tran_glyph conn="49,31,1,1,11">
         <action box="-11,-2,21,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="33,18,16,23">
        <entry box="1,2,14,2"/>
        <exit box="1,4,15,2"/>
       </state_glyph>
      </state>
      <state_glyph node="29,11,31,32">
       <exit box="1,2,9,2"/>
      </state_glyph>
     </state>
     <state name="display">
      <exit brief="led off">led_notify_error(false);
led_show();</exit>
      <state name="dsp_halt">
       <entry brief="displ.&amp;rst halt; err:1, minus:0">led_msg(HALT_MSG);
led_notify_error(true);
led_show();

me-&gt;txHalt = 0;</entry>
       <state_glyph node="26,52,27,6">
        <entry box="1,2,24,2"/>
       </state_glyph>
      </state>
      <state name="dsp_txerr">
       <entry brief="displ.&amp;rst tx_errt; err:1, minus:0">led_display_number(me-&gt;txErr, 16);
//led_display_number((me-&gt;txErr)*-1, 16); //test
led_notify_error(true);
led_show();

me-&gt;txErr = 0;</entry>
       <state_glyph node="26,60,27,6">
        <entry box="1,2,25,2"/>
       </state_glyph>
      </state>
      <state name="dsp_err">
       <entry brief="displ.&amp;rst errt; err:1, minus:1, reset err">//zmieniamy znak by włączyć LED MINUS
led_display_number((me-&gt;err)*-1, 16);
led_notify_error(true);
led_show();

//czyszczenie przyczyny błędu, który spowodował restart
//Watchdog error nie potrzebuje czyszczenia,
//Assert failed trzeba z kolei przeczytać w debugerze
if( (me-&gt;err!=ERR_ASSERT_FAILED) &amp;&amp; (me-&gt;err != ERR_WD_RESET))
    rerr_reset();

me-&gt;err = 0;</entry>
       <state_glyph node="26,68,27,6">
        <entry box="1,2,26,2"/>
       </state_glyph>
      </state>
      <state_glyph node="23,46,36,29">
       <exit box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="dsp_batt">
      <entry brief="display battt; err:0, minus:0">led_display_number(me-&gt;batt, 10);
//led_notify_error(false);
led_show();</entry>
      <state_glyph node="26,76,27,6">
       <entry box="1,2,24,2"/>
      </state_glyph>
     </state>
     <state_glyph node="6,4,63,82"/>
    </state>
    <state_diagram size="80,98"/>
   </statechart>
  </class>
  <class name="SerDispMinMax" superclass="qpc::QHsm">
   <attribute name="minRound" type="int16_t" visibility="0x02" properties="0x00"/>
   <attribute name="maxRound" type="int16_t" visibility="0x02" properties="0x00"/>
   <attribute name="timeoutEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="superAO" type="QActive  *" visibility="0x02" properties="0x00"/>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1/3">
     <action>(void)e;

QS_OBJ_DICTIONARY(&amp;l_serDispMinMax);</action>
     <initial_glyph conn="4,6,4,3,11,10">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="container">
     <tran trig="MIN_TEMP">
      <action brief="save">me-&gt;minRound = Q_EVT_CAST(ValEvt)-&gt;value;</action>
      <tran_glyph conn="7,10,3,-1,16">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <tran trig="MAX_TEMP">
      <action brief="save">me-&gt;maxRound = Q_EVT_CAST(ValEvt)-&gt;value;</action>
      <tran_glyph conn="7,12,3,-1,16">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <tran trig="BTN_PRSS" target="../3">
      <tran_glyph conn="7,21,3,3,7">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="idle">
      <entry brief="post RET_ORTHO_SIG">QACTIVE_POST(me-&gt;superAO,Q_NEW(QEvt, RET_ORTHO_SIG), me);</entry>
      <tran trig="BTN_SHORT" target="../../4">
       <tran_glyph conn="35,22,1,1,10,9,-10">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="14,15,21,9">
       <entry box="1,2,7,2"/>
      </state_glyph>
     </state>
     <state name="floor">
      <entry brief="arm, display">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  MIN_DESC_TICKS, 0U);

led_msg(FLOOR_MSG);
led_show();</entry>
      <tran trig="MINMAX_TIMEOUT" target="../../5">
       <tran_glyph conn="35,36,1,1,9,10,-9">
        <action box="0,-2,19,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="14,28,21,10">
       <entry box="1,2,15,2"/>
      </state_glyph>
     </state>
     <state name="min">
      <entry brief="arm, display">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  MIN_TICKS, 0U);

led_display_number(me-&gt;minRound, 10);
led_show();</entry>
      <tran trig="MINMAX_TIMEOUT" target="../../6">
       <tran_glyph conn="35,50,1,1,9,10,-10">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="14,42,21,10">
       <entry box="1,2,14,2"/>
      </state_glyph>
     </state>
     <state name="ceil">
      <entry brief="arm, display">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  MAX_DESC_TICKS, 0U);

led_msg(CEIL_MSG);
led_show();</entry>
      <tran trig="MINMAX_TIMEOUT" target="../../7">
       <tran_glyph conn="34,63,1,1,9,10,-9">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="14,56,20,9">
       <entry box="1,2,12,2"/>
      </state_glyph>
     </state>
     <state name="max">
      <entry brief="arm, display">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  MAX_TICKS, 0U);

led_display_number(me-&gt;maxRound, 10);
led_show();</entry>
      <tran trig="MINMAX_TIMEOUT" target="../../8">
       <tran_glyph conn="34,76,1,1,9,10,-10">
        <action box="0,-2,16,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="14,69,20,9">
       <entry box="1,2,14,2"/>
      </state_glyph>
     </state>
     <state name="trend">
      <entry brief="arm, display">QTimeEvt_armX(&amp;me-&gt;timeoutEvt,  TREND_TICKS, 0U);

led_msg(FLAT_TREND_MSG);
led_show();</entry>
      <tran trig="MINMAX_TIMEOUT" target="../../3">
       <tran_glyph conn="33,92,1,1,18,-75,-16">
        <action box="0,-2,16,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="14,83,19,11">
       <entry box="1,2,13,2"/>
      </state_glyph>
     </state>
     <state_glyph node="7,5,61,96"/>
    </state>
    <state_diagram size="80,109"/>
   </statechart>
  </class>
  <class name="Control" superclass="qpc::QActive">
   <attribute name="timeout" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1">
     <action>QS_OBJ_DICTIONARY(AO_Control);
(void)e;</action>
     <initial_glyph conn="28,7,4,0,7">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="ctrl">
     <entry brief="arm">QTimeEvt_armX(&amp;me-&gt;timeout,  WD_TIMEOUT_TICKS, WD_TIMEOUT_TICKS);</entry>
     <tran trig="TIMEOUT">
      <action brief="kick wd">iwdg_reset();</action>
      <tran_glyph conn="13,26,3,-1,23">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="13,14,30,22">
      <entry box="1,2,9,2"/>
     </state_glyph>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="Data" superclass="qpc::QActive">
   <documentation>Saves </documentation>
   <attribute name="timer" type="QTimeEvt" visibility="0x02" properties="0x00">
    <documentation>Watching if messages don't drop</documentation>
   </attribute>
   <attribute name="delay" type="QTimeEvt" visibility="0x02" properties="0x00">
    <documentation>margin for messages period</documentation>
   </attribute>
   <attribute name="denominator" type="uint8_t" visibility="0x02" properties="0x00"/>
   <operation name="pubData" type="void" visibility="0x02" properties="0x00">
    <parameter name="min" type="int16_t"/>
    <parameter name="max" type="int16_t"/>
    <code>ValEvt *pe = Q_NEW(ValEvt, MIN_TEMP_SIG);
pe-&gt;denom = me-&gt;denominator;
pe-&gt;value = min;
QF_PUBLISH((QEvt*)pe, me);
pe = Q_NEW(ValEvt, MAX_TEMP_SIG);
pe-&gt;denom = me-&gt;denominator;
pe-&gt;value = max;
QF_PUBLISH((QEvt*)pe, me);

QS_BEGIN(MINIMAX_STAT,me)
    QS_I16(0, min); 
    QS_I16(0, max); 
    QS_I16(0, me-&gt;denominator); 
QS_END()   </code>
   </operation>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1/2">
     <action>(void)e;

//for(int16_t i=0; i&lt;DATA_STOR_SIZE; i++)
//{
//    me-&gt;storage[i] = DROP_MARK;
//}
//me-&gt;current_index = 0;
//me-&gt;denominator = 0;

data_init();

QActive_subscribe(&amp;me-&gt;super, OTEMP_SIG);

QTimeEvt_armX(&amp;me-&gt;timer,  MESSAGE_PERIOD, MESSAGE_PERIOD);

QS_OBJ_DICTIONARY(&amp;l_data);</action>
     <initial_glyph conn="2,2,4,3,32,8">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="cont">
     <tran trig="UPDATE_MINMAX">
      <action brief="compute &amp; publish MIN MAX">int16_t min, max;
data_get(&amp;min, &amp;max);
Data_pubData(me,
    (min==DROP_MARK)?NAN_MINMAX:min,
    (max==DROP_MARK)?NAN_MINMAX:max);</action>
      <tran_glyph conn="7,14,3,-1,36">
       <action box="0,-2,35,2"/>
      </tran_glyph>
     </tran>
     <state name="delay">
      <entry brief="arm delay once">QTimeEvt_armX(&amp;me-&gt;delay,  MESSAGE_MARGIN, 0);</entry>
      <exit brief="request comp&amp;pub">QACTIVE_POST(&amp;me-&gt;super,Q_NEW(QEvt, UPDATE_MINMAX_SIG), me);</exit>
      <tran trig="OTEMP" target="../../2">
       <action brief="save temp, rearm timer">QTimeEvt_rearm(&amp;me-&gt;timer,  MESSAGE_PERIOD);
//Data_saveData(me,Q_EVT_CAST(ValEvt)-&gt;value, Q_EVT_CAST(ValEvt)-&gt;denom);
data_save(Q_EVT_CAST(ValEvt)-&gt;value);
me-&gt;denominator = Q_EVT_CAST(ValEvt)-&gt;denom;</action>
       <tran_glyph conn="38,33,3,1,-12">
        <action box="0,-2,18,4"/>
       </tran_glyph>
      </tran>
      <tran trig="DELAY_TIMEOUT" target="../../2">
       <action brief="save drop">//Data_saveData(me,DROP_MARK, me-&gt;denominator);
data_save(DROP_MARK);</action>
       <tran_glyph conn="38,39,3,1,-12">
        <action box="0,-2,17,4"/>
       </tran_glyph>
      </tran>
      <state_glyph node="38,22,18,21">
       <entry box="1,2,14,2"/>
       <exit box="1,4,17,4"/>
      </state_glyph>
     </state>
     <state name="wait">
      <tran trig="OTEMP">
       <action brief="rearm timer, save temp, request comp&amp;pub">QTimeEvt_rearm(&amp;me-&gt;timer,  MESSAGE_PERIOD);

//Data_saveData(me,Q_EVT_CAST(ValEvt)-&gt;value, Q_EVT_CAST(ValEvt)-&gt;denom);
data_save(Q_EVT_CAST(ValEvt)-&gt;value);
me-&gt;denominator = Q_EVT_CAST(ValEvt)-&gt;denom;

//QEvt *pe = Q_NEW(QEvt, UPDATE_MINMAX_SIG);
//QACTIVE_POST(AO_Data,pe, me);

QACTIVE_POST(&amp;me-&gt;super,Q_NEW(QEvt, UPDATE_MINMAX_SIG), me);</action>
       <tran_glyph conn="10,27,3,-1,13">
        <action box="0,-2,16,7"/>
       </tran_glyph>
      </tran>
      <tran trig="TIMEOUT" target="../../1">
       <tran_glyph conn="26,27,1,3,12">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="10,22,16,20"/>
     </state>
     <state_glyph node="7,4,54,41"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="Button" superclass="qpc::QActive">
   <attribute name="timer" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <statechart properties="QS_FUN_DICT">
    <initial target="../1">
     <action>QActive_subscribe(&amp;me-&gt;super, BTN_EVT_SIG);

QS_OBJ_DICTIONARY(AO_Button);

(void)e;</action>
     <initial_glyph conn="10,4,5,0,6,3">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="idle">
     <tran trig="BTN_EVT" target="../../2">
      <action brief="arm">QTimeEvt_rearm(&amp;me-&gt;timer,  LONG_PRESS_TICKS);
//QTimeEvt_armX(&amp;me-&gt;timer,  LONG_PRESS_TICKS, 0);</action>
      <tran_glyph conn="22,15,1,1,18,10,-18">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="10,7,12,11"/>
    </state>
    <state name="pressed">
     <tran trig="TIMEOUT" target="../../3">
      <action brief="pub LONG">QF_PUBLISH(Q_NEW(QEvt, BTN_PRSS_SIG), me);</action>
      <tran_glyph conn="22,31,1,1,20,9,-20">
       <action box="0,-2,20,2"/>
      </tran_glyph>
     </tran>
     <tran trig="BTN_EVT" target="../../1">
      <action brief="pub SHORT">QF_PUBLISH(Q_NEW(QEvt, BTN_SHORT_SIG), me);</action>
      <tran_glyph conn="22,28,1,1,20,-16,-20">
       <action box="0,-2,20,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="10,22,12,11"/>
    </state>
    <state name="longPressed">
     <tran trig="BTN_EVT" target="../../1">
      <action brief="pub REL">QF_PUBLISH(Q_NEW(QEvt, BTN_REL_SIG), me);</action>
      <tran_glyph conn="22,43,1,1,23,-33,-23">
       <action box="0,-2,20,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="10,36,12,10"/>
    </state>
    <state_diagram size="80,54"/>
   </statechart>
  </class>
  <attribute name="AO_SerDisp" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;l_serDisp.super;</code>
  </attribute>
  <attribute name="the_Ticker0" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>Software timer for tickrate 0 (SOFT_TICKRATE_0)</documentation>
   <code>= &amp;l_ticker0;</code>
  </attribute>
  <attribute name="AO_Control" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;l_control.super;</code>
  </attribute>
  <attribute name="AO_Data" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;l_data.super;</code>
  </attribute>
  <attribute name="AO_Button" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;l_button.super;</code>
  </attribute>
  <operation name="Rcv_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Rcv * const me = &amp;l_rcv;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Rcv_initial));

//QMPool_init(    &amp;msgPool, 
//                            memPoolSto,
//                            sizeof(memPoolSto),
//                            VW_MAX_MESSAGE_LEN);</code>
  </operation>
  <operation name="RcvMsgDec_ctor" type="void" visibility="0x00" properties="0x00">
   <code>RcvMsgDec * const me = &amp;l_rcvMsgDec;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;RcvMsgDec_initial));
</code>
  </operation>
  <operation name="RcvBatDec_ctor" type="void" visibility="0x00" properties="0x00">
   <code>RcvBatDec * const me = &amp;l_rcvBatDec;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;RcvBatDec_initial));
</code>
  </operation>
  <operation name="RcvTempDec_ctor" type="void" visibility="0x00" properties="0x00">
   <code>RcvTempDec * const me = &amp;l_rcvTempDec;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;RcvTempDec_initial));
</code>
  </operation>
  <operation name="SerDisp_ctor" type="void" visibility="0x00" properties="0x00">
   <code>SerDisp * const me = &amp;l_serDisp;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;SerDisp_initial));

//inicjacja komponentu ortho 
me-&gt;orthoCompPtr = SerDispErr_ctor(&amp;me-&gt;super);

//inicjacja drugiego komponentu ortogonalnego
me-&gt;minmaxOrthoPtr = SerDispMinMax_ctor(&amp;me-&gt;super);

//inicjacja timerów
QTimeEvt_ctorX(&amp;me-&gt;blinkEvt, &amp;me-&gt;super, DISP_BLINK_SIG, HARD_TICKRATE_1);
//Dla uniknięcia wyścigu ten timer musi być zrealizowany przez obiekt QTimer
//o priorytecie NIŻSZYM niż AO SerDisp
QTimeEvt_ctorX(&amp;me-&gt;timeoutEvt, &amp;me-&gt;super, TIMEOUT_SIG, SOFT_TICKRATE_0);</code>
  </operation>
  <operation name="SerDispErr_ctor" type="QHsm *" visibility="0x00" properties="0x00">
   <parameter name="superAO" type="QActive * const"/>
   <code>SerDispErr *me = &amp;l_serDispErr;

/* superclass' ctor */
QHsm_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;SerDispErr_initial));
/* superAO will dispatch event down to me */
QTimeEvt_ctorX(&amp;me-&gt;blinkEvt, superAO, ORTHO_BLINK_SIG, HARD_TICKRATE_1);

me-&gt;batt = NANB;
me-&gt;txHalt = 0;
me-&gt;txErr = 0;
me-&gt;err = 0;

return (QHsm *)me;</code>
  </operation>
  <operation name="SerDispMinMax_ctor" type="QHsm *" visibility="0x00" properties="0x00">
   <parameter name="superAO" type="QActive * const"/>
   <code>SerDispMinMax *me = &amp;l_serDispMinMax;

/* superclass' ctor */
QHsm_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;SerDispMinMax_initial));
/* superAO will dispatch event down to me */
QTimeEvt_ctorX(&amp;me-&gt;timeoutEvt, superAO, MINMAX_TIMEOUT_SIG, HARD_TICKRATE_1);

me-&gt;minRound = NAN;
me-&gt;maxRound = NAN;
me-&gt;superAO = superAO;

return (QHsm *)me;</code>
  </operation>
  <operation name="Control_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Control * const me = &amp;l_control;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Control_initial));

//inicjacja timera
QTimeEvt_ctorX(&amp;me-&gt;timeout, &amp;me-&gt;super, TIMEOUT_SIG, HARD_TICKRATE_1);</code>
  </operation>
  <operation name="Data_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Data * const me = &amp;l_data;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Data_initial));

//inicjacja timera
QTimeEvt_ctorX(&amp;me-&gt;timer, &amp;me-&gt;super, TIMEOUT_SIG, SOFT_TICKRATE_0);
QTimeEvt_ctorX(&amp;me-&gt;delay, &amp;me-&gt;super, DELAY_TIMEOUT_SIG, HARD_TICKRATE_1);</code>
  </operation>
  <operation name="Button_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Button * const me = &amp;l_button;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Button_initial));

//inicjacja timera
QTimeEvt_ctorX(&amp;me-&gt;timer, &amp;me-&gt;super, TIMEOUT_SIG, HARD_TICKRATE_1);</code>
  </operation>
 </package>
 <directory name="qm_src">
  <file name="project.h" codec="UTF-8">
   <text>#ifndef project_h
#define project_h

/* define the event signals used in the application ------------------------*/
enum ProjectSignals {
    //Eventy wg typów o rosnącej wielkości
    //QEvt
    VW_SIG  = Q_USER_SIG,    //niskopoziomowy sterownik odebrał message (dobry lub zły to się okaże)
    TX_HALT_SIG,    //nadajnik zraportował nieudany start 
    BTN_EVT_SIG,    //wykryto zmianę stanu przycisku
    BTN_PRSS_SIG,    //przycisk został wciśnięty (generowany przy długim wciśnięciu)
    BTN_REL_SIG,    //przycisk został zwolniony
    BTN_SHORT_SIG,    //krótkie przyciśnięcie (generowane przy zwalnaniu)


    //ErrEvt
    TX_ERR_SIG,    //błędy raportowane przez nadajnik
    ERR_SIG,            //błędy wewnętrzne firmware

    //ValEvt
    OTEMP_SIG,  /* odczyt temp czujnika zewn.*/
    BATT_SIG,    //odczyt napięcia baterii
    MIN_TEMP_SIG,    //minimalna temperatura w  zadanym przedziale czasu
    MAX_TEMP_SIG, //max temp. w zadanym przedziale

    MAX_PUB_SIG,          /* the last published signal */

    //MsgEvt
    MSG_SIG,    //treść odebranego komunikatu

    UPDATE_MINMAX_SIG,    //zlecenie przeszukania zapisanych danych i publikacji min i max
    RET_ORTHO_SIG,    //rządanie powrotu z komponentu ortogonalnego
    DISP_BLINK_SIG,    //migotanie wyświetlacza
    ORTHO_BLINK_SIG,  //ticker dla komponentu ortogonalnego wyświetlacza
    MINMAX_TIMEOUT_SIG,    //sygnał timeoutu dla komponentu orto pt. minimax
    DELAY_TIMEOUT_SIG,    //AO_Data drop outs detection
    TIMEOUT_SIG,

    MAX_SIG                     /* the last signal */
};

/* define symbols */
#include &quot;protocol.h&quot;

$declare(Events::ValEvt)

$declare(Events::ErrEvt)

$declare(Events::MsgEvt)


/* declare other elements... */

#endif /* project_h */</text>
  </file>
  <file name="receiver.h" codec="UTF-8">
   <text>#ifndef receiver_h
#define receiver_h

/* opaque pointers to AOs */
extern QActive * const  AO_Rcv;
extern QActive * const AO_RcvMsgDec;
extern QActive * const AO_RcvBatDec;
extern QActive * const AO_RcvTempDec;

$declare(AOs::Rcv_ctor)
$declare(AOs::RcvMsgDec_ctor)
$declare(AOs::RcvBatDec_ctor)
$declare(AOs::RcvTempDec_ctor)

#endif /* receiver_h */</text>
  </file>
  <file name="receiver.c" codec="UTF-8">
   <text>#include &lt;string.h&gt;
#include &quot;qpc.h&quot;
#include &quot;bsp.h&quot;
//#include &quot;app_conf.h&quot;
#include &quot;link-proto.h&quot;
#include &quot;VirtualWire.h&quot;
//#include &quot;datalog.h&quot;
#include &quot;project.h&quot;
#include &quot;receiver.h&quot;


$declare(AOs::Rcv)

$declare(AOs::RcvMsgDec)

$declare(AOs::RcvBatDec)

$declare(AOs::RcvTempDec)

static Rcv l_rcv;
QActive * const  AO_Rcv = &amp;l_rcv.super;

static RcvMsgDec l_rcvMsgDec;
QActive * const AO_RcvMsgDec = &amp;l_rcvMsgDec.super;

static RcvBatDec l_rcvBatDec;
QActive * const AO_RcvBatDec = &amp;l_rcvBatDec.super;

static RcvTempDec l_rcvTempDec;
QActive * const AO_RcvTempDec = &amp;l_rcvTempDec.super;

$define(AOs::Rcv_ctor)
$define(AOs::Rcv)

$define(AOs::RcvMsgDec_ctor)
$define(AOs::RcvMsgDec)

$define(AOs::RcvBatDec_ctor)
$define(AOs::RcvBatDec)

$define(AOs::RcvTempDec_ctor)
$define(AOs::RcvTempDec)</text>
  </file>
  <file name="serdisp.c" codec="UTF-8">
   <text>#include &quot;qpc.h&quot;
//#include &quot;bsp-serdisp.h&quot;
#include &quot;bsp.h&quot;
#include &quot;project.h&quot;
#include &quot;serdisp.h&quot;
#include &quot;link-proto.h&quot;
#include &quot;led7seg.h&quot;
#include &quot;serdisperr.h&quot;
#include &quot;serdispminmax.h&quot;
#include &lt;limits.h&gt;

Q_DEFINE_THIS_FILE

#define NAN ALL_MINUS

//definicje symboli (poddefinicje są zdefinowane w bsp.h)
//do ilu sek. od ostatniego msg dana będzie uznana za aktualną
#define ASSUME_AGED    ((DISPLAY_ASSUME_AGED)*60*BSP_SOFT_TIMER_TICKS_PER_SEC)
//po ilu sekundach temp. zewnętrzna będzie uznana za całkowicie nieaktualną
#define ASSUME_OUTDATED  ((DISPLAY_ASSUME_OUTDATED)*60*BSP_SOFT_TIMER_TICKS_PER_SEC)
//częstotliwość mrugania wyświetlacza dla ASSUME_AGED
#define BLINK_DISPLAY (BSP_TICKS_PER_SEC/DISPLAY_AGED_BLINK_PER_SEC/2)

/* local objects -----------------------------------------------------------*/

$declare(AOs::SerDisp)
static SerDisp l_serDisp; /* the sole instance of the SerDisp active object */
//static QTicker l_ticker0; /* ticker active object for tick rate 0 */

/* Public-scope objects ----------------------------------------------------*/

$define(AOs::AO_SerDisp)
//$define(AOs::the_Ticker0)

/* Active object definition ================================================*/

$define(AOs::SerDisp_ctor)
$define(AOs::SerDisp)
</text>
  </file>
  <file name="serdisp.h" codec="UTF-8">
   <text>#ifndef serdisp_h
#define serdisp_h

/* symbols definitions */


/* active objects' &quot;constructors&quot; */

$declare(AOs::SerDisp_ctor)

/* instantiation of the orthogonal components */


/* opaque pointer to AOs */

$declare(AOs::AO_SerDisp)
//$declare(AOs::the_Ticker0)

#endif /* serdisp_h */</text>
  </file>
  <file name="timer.h" codec="UTF-8">
   <text>#ifndef timer_h
#define timer_h

/* symbols definitions */


/* active objects' &quot;constructors&quot; */


/* instantiation of the orthogonal components */


/* opaque pointer to AOs */

$declare(AOs::the_Ticker0)

#endif /* timer_h */</text>
  </file>
  <file name="timer.c" codec="UTF-8">
   <text>#include &quot;qpc.h&quot;
#include &quot;serdisp.h&quot;

Q_DEFINE_THIS_FILE

/* local objects -----------------------------------------------------------*/

static QTicker l_ticker0; /* ticker active object for tick rate 0 */

/* Public-scope objects ----------------------------------------------------*/

$define(AOs::the_Ticker0)

/* Active object definition ================================================*/
</text>
  </file>
  <file name="serdisperr.h" codec="UTF-8">
   <text>#ifndef serdisperr_h
#define serdisperr_h

/* symbols definitions */

/* active objects' &quot;constructors&quot; */

$declare(AOs::SerDispErr_ctor)

/* instantiation of the orthogonal components */


/* opaque pointer to AOs */


#endif /* serdisperr_h */</text>
  </file>
  <file name="serdisperr.c" codec="UTF-8">
   <text>#include &quot;qpc.h&quot;
#include &quot;bsp.h&quot;
#include &quot;project.h&quot;
#include &quot;serdisperr.h&quot;
//#include &quot;link-proto.h&quot;
#include &quot;led7seg.h&quot;
#include &quot;err.h&quot;
#include &quot;rerror.h&quot;

Q_DEFINE_THIS_FILE

#define NANB ALL_QUESTION

//definicje symboli (poddefinicje są zdefinowane w bsp.h)
//Czas włączenia diody w razie wystąpienia błędów. W tikach
#define LED_ON    ERR_NOTICE_ON*BSP_TICKS_PER_SEC/1000
//Czas przerwy w błyskaniu LED w razie wystąpienia błędów. W tikach
#define LED_OFF   ERR_NOTICE_OFF*BSP_TICKS_PER_SEC/1000

/* local objects -----------------------------------------------------------*/

$declare(AOs::SerDispErr)
static SerDispErr l_serDispErr; /* the sole instance of the SerDisp active object */


/* Public-scope objects ----------------------------------------------------*/

/* Active object definition ================================================*/

$define(AOs::SerDispErr_ctor)
$define(AOs::SerDispErr)
</text>
  </file>
  <file name="control.h" codec="UTF-8">
   <text>#ifndef control_h
#define control_h

/* symbols definitions */

/* active objects' &quot;constructors&quot; */

$declare(AOs::Control_ctor)

/* instantiation of the orthogonal components */


/* opaque pointer to AOs */
$declare(AOs::AO_Control)

#endif /* control_h */</text>
  </file>
  <file name="control.c" codec="UTF-8">
   <text>#include &quot;qpc.h&quot;
#include &quot;bsp.h&quot;
#include &quot;project.h&quot;
#include &quot;iwdg.h&quot;
#include &quot;control.h&quot;

Q_DEFINE_THIS_FILE

//definicje symboli (poddefinicje są zdefinowane w app_conf.h)
#define WD_TIMEOUT_TICKS   (BSP_TICKS_PER_SEC*BSP_WD_TIMEOUT/1000)

/* local objects -----------------------------------------------------------*/

$declare(AOs::Control)
static Control l_control; /* the sole instance of the SerDisp active object */


/* Public-scope objects ----------------------------------------------------*/

$define(AOs::AO_Control)
//$define(AOs::the_Ticker0)

/* Active object definition ================================================*/

$define(AOs::Control_ctor)
$define(AOs::Control)</text>
  </file>
  <file name="data.h" codec="UTF-8">
   <text>#ifndef data_h
#define data_h

#include &quot;led7seg.h&quot;

/* symbols definitions */

#define NAN_MINMAX  (ONE_QUESTION)

/* active objects' &quot;constructors&quot; */

$declare(AOs::Data_ctor)

/* instantiation of the orthogonal components */


/* opaque pointer to AOs */
$declare(AOs::AO_Data)

#endif /* data_h */</text>
  </file>
  <file name="data.c" codec="UTF-8">
   <text>#include &quot;qpc.h&quot;
#include &quot;bsp.h&quot;
#include &quot;app_conf.h&quot;
#include &quot;protocol.h&quot;
#include &quot;project.h&quot;
#include &quot;datahist.h&quot;
#include &quot;data.h&quot;

Q_DEFINE_THIS_FILE

#define MESSAGE_PERIOD (BSP_MSG_INTERVAL * BSP_SOFT_TIMER_TICKS_PER_SEC)
#define MESSAGE_MARGIN (((MSG_REPEAT_NUM-1)+5) * BSP_TICKS_PER_SEC)


/* local objects -----------------------------------------------------------*/

$declare(AOs::Data)

static Data l_data; /* the sole instance of this active object */


/* Public-scope objects ----------------------------------------------------*/

$define(AOs::AO_Data)

/* Active object definition ================================================*/

$define(AOs::Data_ctor)
$define(AOs::Data)</text>
  </file>
  <file name="button.h" codec="UTF-8">
   <text>#ifndef button_h
#define button_h


/* symbols definitions */

/* active objects' &quot;constructors&quot; */

$declare(AOs::Button_ctor)

/* instantiation of the orthogonal components */


/* opaque pointer to AOs */
$declare(AOs::AO_Button)

#endif /* button_h */</text>
  </file>
  <file name="button.c" codec="UTF-8">
   <text>#include &quot;qpc.h&quot;
#include &quot;bsp.h&quot;
#include &quot;app_conf.h&quot;
#include &quot;protocol.h&quot;
#include &quot;project.h&quot;
#include &quot;button.h&quot;

Q_DEFINE_THIS_FILE

//definicje symboli (poddefinicje są zdefinowane w app_conf.h)

#define LONG_PRESS_TICKS (LONG_PRESS_STRETCH * BSP_TICKS_PER_SEC/1000)

/* local objects -----------------------------------------------------------*/

$declare(AOs::Button)

static Button l_button; /* the sole instance of this active object */


/* Public-scope objects ----------------------------------------------------*/

$define(AOs::AO_Button)

/* Active object definition ================================================*/

$define(AOs::Button_ctor)
$define(AOs::Button)</text>
  </file>
  <file name="serdispminmax.h" codec="UTF-8">
   <text>#ifndef serdispminmax_h
#define serdispminmax_h

/* symbols definitions */

/* active objects' &quot;constructors&quot; */

$declare(AOs::SerDispMinMax_ctor)

/* instantiation of the orthogonal components */


/* opaque pointer to AOs */


#endif /* serdispminmax_h */</text>
  </file>
  <file name="serdispminmax.c" codec="UTF-8">
   <text>#include &quot;qpc.h&quot;
#include &quot;bsp.h&quot;
#include &quot;project.h&quot;
#include &quot;serdispminmax.h&quot;
//#include &quot;link-proto.h&quot;
#include &quot;led7seg.h&quot;
#include &quot;err.h&quot;
#include &quot;rerror.h&quot;

Q_DEFINE_THIS_FILE

#define NAN ONE_QUESTION

#define MIN_DESC_TICKS    (MIN_DESC_MS*BSP_TICKS_PER_SEC/1000)
#define MIN_TICKS        (MIN_MS*BSP_TICKS_PER_SEC/1000)
#define MAX_DESC_TICKS    (MAX_DESC_MS*BSP_TICKS_PER_SEC/1000)
#define MAX_TICKS        (MAX_MS*BSP_TICKS_PER_SEC/1000)
#define TREND_TICKS    (TREND_MS*BSP_TICKS_PER_SEC/1000)

/* local objects -----------------------------------------------------------*/

$declare(AOs::SerDispMinMax)
static SerDispMinMax l_serDispMinMax; /* the sole instance of the SerDisp active object */


/* Public-scope objects ----------------------------------------------------*/

/* Active object definition ================================================*/

$define(AOs::SerDispMinMax_ctor)
$define(AOs::SerDispMinMax)
</text>
  </file>
 </directory>
</model>
